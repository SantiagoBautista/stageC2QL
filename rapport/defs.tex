Les définitions des différents opérateurs présentes dans la thèse de 2016
sont données en français, ce qui facilite leur compréhension, mais rend
impossible une preuve mathématique de la correction des lois les concernant.

J'ai donc commencé par poser des définitions formelles des fonctions du langage
C2QL.

Pour former ces définitions, j'ai du faire des choix à plusieurs reprises.
À chaque fois, j'ai utilisé les deux mêmes critères pour guider mes choix:
d'une part il faut que les définitions que je choisi permettent au langage
d'être le plus expressif possible, d'autre part il faut que les définitions
choisies facilitent une démonstration rigoureuse de la correction
des lois de commutation.

Pour un document contenant l'ensemble des définition,
se référer à l'annexe A.

Dans ce rapport je vais me centrer principalement
sur celles des définitions où il y a eu des choix à faire
(en exposant les motivations qui ont permit d'effectuer un choix
plutôt qu'un autre) et celles des définitions où il y a des différences par rapport
aux définitions qui étaient suggérées par les notations de la thèse,
en expliquant les motivations de ces différences.

\subsubsection*{Des tuples ou des fonctions?}
Dans son livre de 1982, Ullman parle de deux
façons de définir les relations (tables) de l'algèbre relationnelle:
soit comme un sous-ensemble d'un produit de domaines
(donc comme un ensemble de tuples, où chaque
tuple représente une ligne
de la table et chaque coordonnée de chaque tuple correspond
à la valeur pour un attribut donné), soit comme un ensemble de fonctions
définies sur l'ensemble des attributs (chaque fonction correspond donc
à une ligne de la table, et la valeur d'un attribut pour une ligne donnée
est son image par cette fonction).

Ullman décide d'utiliser la première définition pour le reste de son livre,
et ne détaille pas plus la deuxième définition. C'est pourtant cette deuxième
définition que j'ai décidé de prendre dans ce cas ci, puisque que ce soit
pour le chiffrement comme pour la fragmentation, on fait ici référence aux différentes
colonnes d'une table par leur nom (toutes les colonnes ont un nom, et tous les
noms des colonnes sont différents) et il est donc plus facile de raisonner,
par exemple, sur la fragmentation, avec cette définition-là:
en effet, la fragmentation se définit alors en thermes de simples restrictions
sur certains ensembles.

\subsubsection*{Des sélections portant sur plus d'un attribut à la fois.}
Dans certaines des lois présentes dans la thèse, la notation
suggère que les prédicats utilisés lors des filtrages ne portent que sur
un seul attribut à la fois.

Ainsi, par exemple, dans la loi (7) à la page 30 de la thèse
concernant la commutation entre la jointure naturelle et la
sélection,
on lit
\begin{align*}
\sel_{p\alpha \wedge q\beta} \circ \Join 
& \equiv \Join \circ (\sel_{p\alpha}, \sel_{q\beta})
& \text{si $\alpha \in \Delta$ et $\beta \in \Delta'$}
\end{align*}
où $\Delta$ et $\Delta'$ représentent respectivement le schéma relationnel
du premier argument et le schéma relationnel du deuxième argument.

Cette notation suggère que les prédicats $p$ et $q$ portent
chacun sur un seul attribut (respectivement $\alpha$ et $\beta$).

Le problème est qu'il y a certains prédicats qui ne peuvent
pas ce décomposer en des prédicats portant chacun sur un seul attribut.

Par exemple, si on dispose d'une base données concernant
des ornithorynques, qu'un des attributs de la base de données indique
la date où l'ornithorynque a vu un kangourou pour la première fois,
et qu'un autre des attributs indique la date où l'ornithorynque a pondu des oeufs
pour la première fois,
et que l'on ne veut s'intéresser qu'aux ornithorynques ayant vu des kangourous avant
de pondre des œufs pour la première fois, alors le prédicat
("date de première vision d'un kangourou" < "date de première ponte des oeufs")
ne peux pas être décomposé en deux prédicats qui porteraient l'un sur 
la date de la première vision d'un kangourou et l'autre sur la date de la 
première ponte d'œufs.

Ainsi, dans ma définition de ce qu'est une sélection et ce qu'est un prédicat,
j'ai supposé que la valeur de vérité d'un prédicat dépendait de plusieurs
attributs à la fois, et pour refléter cela j'utilise la notion de
\emph{domaine d'un prédicat}.

Avec cette définition là, la loi de commutation entre la jonction
et la sélection devient
\begin{align*}
\selP \circ \Join
& = \Join \circ (\selP, \id)
& \text{si $\dom(p) \subset \delta_1$}
\label{seljoin1}\\ 
\selP \circ \Join
& = \Join \circ (\id, \selP)
& \text{si $\dom(p) \subset \delta_2$}
\end{align*}
(où $\delta_1$ et $\delta_2$ sont les schémas relationnels de, respectivement,
le premier et le deuxième argument).

\subsubsection*{Compter, ou agréger et réduire?}
Le développeur peut vouloir agir sur plusieurs lignes à la fois.

Le choix qui a été fait dans la thèse, c'est de traiter l'exemple
de la fonction count, qui permet de regrouper, \emph{en les comptant},
les lignes ayant les mêmes valeurs pour un certain ensemble d'attributs.

Je me suis posé la questions de savoir si les opportunités d'optimisation
exposées dans la thèse par rapport à la fonction count et à sa façon de commuter
avec les autres fonctions lui étaient propres, ou si elles étaient généralisables
à toutes les fonctions d'agrégation. Plutôt que de m'intéresser à la fonction
count, je me suis donc intéressé aux fonctions group et fold, qui permettent
de regrouper, \emph{en appliquant une fonction quelconque aux autres attributs},
les lignes ayant les mêmes valeurs pour un certain ensemble d'attributs.

\subsubsection*{Défragmentation et jointure, de faux jumeaux}
Dans un premier temps, j'avais essayé de définir la défragmentation verticale comme
un cas particulier de jointure naturelle (où l'attribut en commun serait
l'identifiant de la ligne). Lors de la jointure, il faut bien définir un comportement
pour les identifiants. 

Puisqu'une seule ligne dans les tables à joindre
peut produire plusieurs lignes dans le résultat d'une jointure, 