* Grandes lignes
** Définir une notion de complétude pour les lois algébrique
*** Première idée: 
[[*Première idée de critère de complétude][Complétude formelle: exprimer toutes les requêtes équivalentes]]

Intuition: J'ai l'impression que pour que ce critère de
complétude puisse être sattisfait, il faudrait créer des nouvelles
lois identité, pour pouvoir faire apparaître au besoin toutes les différentes
fonctions dont peut être composée une requête C2QL


*** Deuxième approche:
Moins formellement, on peut garder la même approche que Ronan et vérifier si
+ Les catégories de lois qu'il propose comprennent toutes les transformations
 qu'on peut vouloir faire
+ Chaque catégorie est complète


*** Troisième approche
Vu que toutes les lois algébriques de C2QL s'intéressent à la composition,
voir à la commutativité, de différentes fonctions,
une troisième approche serait de 
dresser un *tableau* pour toutes les composition de deux fonctions de C2QL.


** Établir la correction des lois algébriques
*** Correction sémantique
Pour la correction sémantique d'une loi algébrique on peut prendre
pour définition celle qui à priori est la définition d'Ullman (82) :
Deux fonctions sont sémantiquement équivalentes si elle coïncident
sur l'ensemble de toutes les relations, indépendament du schéma relationnel

Pour démontrer la correction sémantique, il me semble que la seule chose
qui peut s'avérer gênante est la présence de comportements *implicites* dans
les lois fournies. En effet, la loi (20) par exemple [page 66 de la thèse]
nécessite d'une synchronisation/séquentialisaiton des calculs effectués
sur chacun des deux fragments pour être juste.
Cette synchronisation est un effet de bord, qui n'apparâit pas 
dans l'écriture de la requête comme composition de fonctions
(parce que de fait, les fonctions du langage C2QL ne sont pas des fonctions
pures).

Il a été mentionné qu'une extension possible serait de rendre *explicite* 
dans C2QL la gestion des deux bases de données / clouds distinct(e)s...
Si cela est fait, l'information transmise d'une DB à l'autre serait
de ce fait rendue explicite (et donc en particulier la synchronisation
nécessaire pour la tranformation (20) serait explicite) et cela
résoudrait la gêne que j'ai exprimé précédemment.

*** Correction de l'équivalence de confidentialité
Le mantient de la confidencialité, lui aussi, repose grandement
sur des mécanismes potant sur
- le rapatriment des données côté client
- la nature des informations transmises à tel ou tel fragment de la base de données
Prouver que les transformations préservent la confidentialité pourrait donc
également être facilité par l'introduction explicite de la genstion
des diférents clouds et des comunications entre les différents agents.
Dans le travail déjà effectué, cette introduction a surement lieu lors de la traduction
en pi-calcul.


** Extensions possibles

*** Plus de deux fragements
Actuellement les fonctions de fragmentation/défragmentation
sont faites pour fragmenter/défragmenter en/depuis 2 segments.
Une idée pourrait être de généraliser ces fonctions pour
travailler avec un nombre quelconque de segments.


*** Plus d'un utilisateur
Pour le moment, le langage a été construit en considérant qu'il y a
un seul utilisateur du service à la fois, "Alice".
Faudrait-il étendre le langage pour gérer plusieurs utilisateurs qui
utilisent la ressource au même temps?


*** Autres propriétés de sécurité que Privacité
En ce moment, le langage permet au développeur
de réfléchir sur comment il va composer les
mécanismes de sécurité pour préserver la privacité/confidentialité
des données.
On pourrait introduire également dans le langage des mécanismes
permettant de préserver d'autres propriétés de sécurité,
telles que *l'intégrité*, par exemple.


*** Faire apparaître dans le langage la répartition entre plusieurs clouds
En ce moment, la gestion des différents clouds (nécessaire pour la
gestion correcte de la fragmentation) est faite implicitement,
et manuellement.
Des idées pourraient être soit de l'automatiser (en fonction des contraintes
de privacité, suggérer une répartition qui marche) soit de la rendre
explicite dans le langage.


*** Si ce n'ai déjà fait, généraliser avec group/fold au lieu de count
Dans la thèse, toutes les lois sont exprimées avec count
Un langage disposant des fonction group et fold étant plus expressif
qu'un langage ne disposant que de count,
je trouverai ça intéressant de, si ce n'est déjà fait,
intégrer complétement les fonctions group et fold au langage.


** Autres

*** Compilation vers proVérif
En ce moment, la transformation vers le pi-calcul
est codée, mais pas celle vers proVérif.
Coder la transformation vers proVérif
permettrait de vérifier automatiquement la correction
des programmes codés en C2QL


*** Modifications visant à simplifier les preuves
Si nécessaire, il est possible de modifier le langage
pour faciliter les preuves



* Choses à faire (dans l'immédiat)
** C2QL
*** S'intéresser à la complétude du système de lois algébriques
**** Faire la liste des lois algébriques
J'ai réuni dans un seul endroit toutes les lois, reformulées
[[file:lois/ensemble_lois.pdf][Ensemble des lois]]

***** DONE Demander à Ronan le code tex
Si je peux avoir le fichier .tex de la thèse ou de l'article,
cela m'éviterait de devoir taper de 0 toutes les loi

***** DONE Regrouper les lois apparaissant dans la thèse 
[[file:lois/ensemble_lois_these.pdf][Ensemble des lois apparaissant dans la thèse]]
Emplacements de référence des différentes lois dans la thèse: pages 30 et 63


***** DONE Regarder si elles contiennent les lois apparaissant dans l'article
Non.
+ Dans l'article les lois sont formulées en thermes de group et non de count
+ les lois de sélection sont plus rigoureuses (domaines <- selec sur plus
d'un attribut à la fois)
+ Il y a à la fois de la fragmentation verticale 
et de la fragmentation horizontale
***** DONE Choisir quel ensemble de lois garder initialement
****** DONE Se familiariser avec les macros LaTeX / en créer des propres
******* projections
\pi_{\delta} suffit
******* sélections
\sigma_p suffit
******* frag, defrag, crypt et decrypt
Je vais déclarer des opérateurs amsmath
******* group/fold
Je trouve plus pertinent de travailler avec les fonctions
group et fold, plus générales, que avec la fonction count, qui est
un cas particulier.

\mathrm{group}_{delta}
\mathrm{fold}_{f, z}
****** DONE Faut-il garder la fragmentation horizontale?
Pas nécessaire d'écrire toutes les lois, juste la mentionner
****** Garder les lois de projection de la thèse, pas de l'article
Les définitions avec les intersections sont plus claires et probablement
plus justes que les distinctions a/aBarre


**** Définir une notion de complétude du système de lois
***** DONE Première idée de critère de complétude
Vu que l'objectif de C2QL est d'aider le développeur
à composer les mécanismes de sécurité de sorte à optenir un système
sûr, efficace et nuagique, pour l'instant il me semble que la notion de complétude
qu'il serait le plus intéressant de vérifier est:

À partir d'une requête C2QL, l'ensemble des lois
permet-il d'exprimer toutes les requêtes
étant sémantiquement équivalantes à la requête initiale?

Si cette propriété de complétude était vérifiée, on serait sûrs de pouvoir
optenir la requête la mieux optimisée, quel que soit le critère d'optimisation.

***** DONE Deuxième approche du critère de complétude
[[*Deuxième approche:][Complétude informelle: ensmb des catégories, et catégories elles-mêmes]]

***** DONE Lire Ullman pour réfléchir à la pertinance des critères
Peut-être Ullman définit-il un autre critère de complétude pour
l'ensemble de ses lois? Peut-être définit-il ce critère-ci et le
prouve pour son ensemble de lois?

Non. Ullman ne se soucie pas de complétude.

***** DONE Troisième approche: Toutes les compositions 2 à 2
Le but de toutes les lois algébriques est de, par permutation,
permettre une optimisation de la requête exécutée.

On serait du coup sûrs d'avoir explorée complétement
cette approche si *pour toute paire de fonctions C2QL* on
a une loi décrivant la possibilité, les conditions et
le résultat d'une permutation entre elles.

***** DONE Chercher dans Supernova (Univ Rennes 1) article sur la complétude
Le plus proche que j'ai pu trouver est un article d'économie sur
la modélisation mathématique de, grosso modo, le pouvoir d'achat
des ménages...
[[file:completude_economie.pdf][Systèmes complets de fonctions de demande]]


**** Vérifier si le système de lois vérifie le critère de complétude
***** Pour la première approche: échec 
Le formalisme que j'ai essayé d'introduire pour démontrer la complétude de
manière formelle peut être trouvé ici:
[[file:completude/premiere_tentative.pdf][Première tentative de complétude]]
****** Remarque: c'est aussi une histoire de complétude au sens de la logique! 
En logique, on a des systèmes de déduction qui, opérant sur la syntaxe, permet,
à partir d'un ensemble initial de formules, de déduire d'autres formules.
Lorsqu'on a un système de déduction, on s'intéresse à deux choses:
+ La *correction* du système de déduction
Si on peut déduire une formule F' à partir d'une formule F,
est-ce que F' est conséquence *sémantique* de F?
+ La *complétude* du système de déduction
Si on a une formule F' qui est conséquence sémantique d'une formule F,
peut-on déduire F' à partir de F?

Vouloir démontrer la complétude du système de lois telle que formulée
initialement revient à vouloir montrer qu'avec les régles de déduction
correspondant aux lois algébriques que l'on a, on peut déduire toute
tautologie de l'ensemble de formules vide.

C'est donc aussi un problème de complétude au sens logique du terme.

***** DONE Pour la deuxième approche
Il manque des lois pour le fold, une des lois pour crypt, etc...

***** DONE Pour la troisième approche
 Tableau des lois existant actuellement + \crypt\circ\defrag
[[file:completude/fait.pdf][Etat de la complétude dans la thèse au sens de la troisième approche]]


**** Compléter le système de lois
Ceci sera fait pour la troisième approche,
la première étant probablement impossible et la deuxième
étant contenue dans la troisième.

***** DONE Dresser et *compléter* le tableau de lois de commutation
[[file:completude/nouveau.pdf][Etat actuel de la complétude au sens de la troisième approche]]



*** Remplacer count par group/fold...
**** ... dans les lois
***** DONE Prendre les lois de group de l'article, plutôt que les lois de group
***** DONE ajouter des lois pour le fold
**** DOING dans l'implémentation actuelle de C2QL
Il faudrait aussi le faire, du coup, dans celle de privy


*** Sémantique des fonctions et des formules
**** DONE Définir la sémantique des fonctions utilisées
En justifiant les choix faits, en particulier dans leurs
différences avec ce qui existe actuellement

La définition est faite:
[[file:semantique/definitions.pdf][Définition formelle des fonctions C2QL]]

Il reste à synthétiser les choix qui ont été faits et leurs raisons


**** Démontrer la correction sémantique des lois
La démonstration est en cours:
[[file:demonstrations/demos.pdf][Démonstrations des lois algébriques sur C2QL]]


** ORGanisation
*** DONE Passer mes notes en ORG mode
Fait :-)
[[*Prise de notes][Prise de notes]]


*** DONE Créer un dépôt git
[[https://github.com/SantiagoBautista/stageC2QL.git][Dépôt git du stage]]



* Erreurs trouvées
** Composition de plusieurs projections
(p. 30 de la thèse) Projeter sur plusieurs sous-ensembles
en cascade revient à projeter sur l'intersection, et non sur l'union

Pour la sémantique qu'il donne à \pi_{a_1, ..., a_n},
voir exemple page 29 ou définition page 28

*** Contre-exemple 
Si on considère la relation r suivante
| a_1 | a_2 |
|-----+-----|
| a   |   1 |
| b   |   2 |
son image par $\pi_{a_2}$ est
| a_2 |
|-----|
|   1 |
|   2 |
dont l'image par $\pi_{a_1}$ est la table vide

Ainsi, l'image de r par
$\pi_{a_1} \circ \pi_{a_2}$ est la table vide.

Par contre, l'immage de r par
$\pi_{a_1, a_2}$
est la table r elle-même,
qui est différente de la table vide.

Ainsi donc, la loi (3) à la page 30 de la thèse est fausse.





** Chiffrement et sélection
Dans l'article, pour les lois (14) et (15),
la discussion ne devrait pas porter sur dom(p)\in\P(a)
mais sur dom(p) \cap a = \emptyset
*** En fait, cela a été  corrigé dans la thèse
Mais la formulation de la correction ne me semble pas la bonne


*** Contre-exemple
On prend pour prédicat p 
p: a_1 + a_2 < 10

pour fonction de chiffrement s
s: n |-> n+50

et pour ensemble des attributs chiffrés a
a: {a_1}

Le domaine de p est alors {a_1, a_2}
qui n'est pas une partie de a.
On est donc dans les hypothèses mentionnées
dans l'article pour la loi (14)

On s'intéresse à la relation r
| a_1 | a_2 |
|-----+-----|
|  51 |   2 |

L'image de r par
$\sel_p \circ \decrypt{s}{a_1}$
est la relation
| a_1 | a_2 |
|-----+-----|
|   1 |   2 |

L'image de r par
$\decrypt{s}{a_1} \circ \sel_p$
est la relation vide.

Ainsi donc, la relation (14)
dans l'article est fausse.
(Car la condition donnée n'est pas assez restrictive)

Inversement, la loi (15), qui est là pour être appliquée
lorsque la loi (14) ne s'applique pas, est, dans l'article,
trop restrictive.



** Projection et défragmentation
Si on ne suppose pas que les schémas relationnels
sont disjoints, la quantité de droite peut être définie
sans que la quantité de gauche soit définie.
*** DONE Formuler contre-exemple et l'envoyer à Fatima, Ronan et Mario


* Choix dans les définitions
** Définition sémantique de "relation"
Dans un premier temps, j'ai voulu définir une relation juste comme la table de ses valeurs.
Mais cela me posait le problème suivant:
une même relation pouvait correspondre à des schémas relationnels différents...
alors qu'en soit une relation n'a qu'un seul schéma relationnel...

Dans un deuxième temps, j'ai voulu définir une relation comme un couple de
schéma relationnel et de table des valeurs,
mais avec cette définition, la formalisation de ce qu'est une projection n'était pas
naturelle, les attributs n'apparaissant pas vraiment dans la table.

C'est alors que dans un troisième temps j'ai compris l'intérêt de la deuxième définition
d'Ullman: une relation est un ensemble de fonctions.
La notion de fonction encapsule efficacement et synthétiquement à la fois 
cette existence et unicité du schéma relationnel, et cette idée de valeurs.


** Définitions relatives à la jointure et la fragmentation
Les notions intermédiaires que je souhaitait introduire pour la
défragmentation et pour la jointure étant très proches
(unificateur, lieu d'unification, concaténation...)
cela semblait confus de leur donner des noms différents...

C'est pour cela que j'ai choisi de voir la défragmentation comme un cas particulier
de jointure.
*** Problème qui se pose : indentifiants pour les jointures naturelles
Doit-on imposer que l'identifiant fasse partie des attributs communs (égaux)?

A priori non, car on peut vouloir faire une jointure où l'un des membres serait
issu d'un calcul (d'une opération d'agrégation) que l'on voudrait rajouter à l'autre
membre...

Mais alors à l'issue de la jointure on pourrait se retrouver à
+ avoir des identifiants qui n'ont pas de sens vis à vis
du reste du système
+ / ne pas avoir d'identifiant
+ / devoir choisir entre différents identifiants
??
Je choisi de donner pour identifiant au lignes du résultat
la concaténation (de listes) des identifiants précédents.
C'est l'option qui garantit qu'il n'y a aucune perte d'information
(quitte à ce que l'information pas perdue puisse ne pas être rélévante
vis à vis du reste du système)

*** Lieu de jonction vs attributs en commun
Si on définit la notion de lieu de jonction,
que faire avec des attributs communs qui n'auraient pas la même valeur?


** Définition de l'aggrégation
Pour l'instant le choix que j'ai fait lorsqu'on regroupe
est de faire apparaître les listes des différentes valeurs
pour les attributs ne faisant pas partie des attributs de regroupement.

Cependant, ceci n'est pas ce que fait SQL:
pour les attributs n'ayant pas servi à regrouper,
SQL ne permet que d'afficher des fonctions sur l'ensemble des valeurs.

Mon approche à moi est plus modulaire/fragmentaire/fonctionnelle
en ce qu'elle permet de raisonner sur les effets de la fonction \group seule
et après de la composer avec les autres fonctions, dont fold notament.

Mais mon approche ne semble pas naturelle: dans la définition sémantique
elle nécessite l'introduction de beaucoup trop de couches de concepts intermédiaires,
dont une que je n'arrive pas à nomer: celle qui construit une ligne du résultat
à partir des valeurs de groupe


** La notion d'équivalence n'est pas forcément la bonne
En réalité il s'agit de transformations, qui 
(du point de vue d'un ordinateur aveugle)
ne se comportent pas pareil
selon qu'on les applique dans un sens ou dans l'autre.

En effet, dans le cas de join et défrag, defrag \circ \Join
peut toujours être transromé en \Join \circ \defrag, mais 
l'inverse n'est pas toujour vrai.
C'est aussi le cas des lois 3, ...

Non non non, en soit, il y a pour certains lois des sens
pour lesquels il semblerait qu'on peut se passer de la condition..
mais c'est seulement parce qu'on a la condition dans une autre hypothèse
(à savoir "l'expressioin d'origine a du sens") donc
en vrai on est pas vraiment en train de se passer de l'hypothèse...

Donc la notion d'équivalence était bel et bien la bonne


* Choix dans les lois
Les notes ci-après ne sont largement pas complètes,
il faudra que j'y revienne pour lister/synthétiser tous les
choix qui ont été faits et leurs raisons

** Projection et jointure
Puisqu'on passe d'une jointure sur un attribut à une jointure sur un ensemble
d'attributs, 
la condition sur le \alpha devient  \delta_1 \cap \delta_2 \subset \delta \cap \delta'
et est nécessaire pour que le nombre de lignes soit le même (et donc pour que les
résultats puissent être les mêmes)


* Problèmes dans mes définitions
** Définition de la jointure ne correspondait pas avec jointure naturelle
La définition SQL comme la définition d'Ullman (produit cartésien puis filtrage)
concordent entre elles et ma définition ne correspond pas.

Serait-ce finalement une bonne idée de travailler avec le produit cartésien?

J'ai donc modifié ma définition pour qu'il n'y ait pas forcément correspondance
exacte entre les lignes lors d'un join et que ma définition soit SQL-compatible.


** En fait, les schèmas relationnels sont connus
J'ai formulé une partie de mes lois en voulant que les conditions ne portent que sur les fonctions...
mais en soi les schémas relationnels des tables en entrée sont connus, car c'est une donnée statique,
propre au programme en question, et non pas une donnée dynamique qui serait propre au contenu des relations.


** Deux choix à faire
*** Adopte-t-on la définition join = select o x ? Non
Ou alors se restreint-on à une sorte de JOIN LEFT avec
la définition ensembliste?

J'ai choisi la définition ensembliste parce que tout en étant
suffisemment expressive elle permet de faire plus facilement une
démonstration formelle des lois de commutation.


*** Comment faire intervenir défragmentation et jointure?
La défragmentation est vue comme un cas particulier de jointure.


** DONE Les identifiants post-jointure ne sont pas des identifiants
Si on s'amuse à faire des jointures successives et des unions à partir
des mêmes relations de base mais en projetant d'un côté et pas de l'autre,
on peut peut-être arriver à avoir deux lignes différentes qui auraient le même identifiant... :'(

C'est pour ça que j'ai fait le choix de créer des identifiants frais
lors d'une jointure.


* Prise de notes
** Doutes résolus
*** La transformation de requête de base en requête optimisée est-elle automatisée?
Non.
**** Discours actuel
Les transformations à appliquer sont laissées au choix du développeur en
fonction de ce qu'il veut optimiser spécifiquement pour son programme
**** Travail futur
Le développeur pourrait rentrer une liste de priorités de critères à optimiser
pour son programme, et en se basant sur cette liste, le choix
des lois à appliquer pourrait être automatisé, pour aboutir automatiquement
à la requête C2QL optimale.


*** Que vérifie le typage Idris?
Actuellement, le système de typage Idris sert à vérifier
que la composition faite aura un sens au moment de l'exécution
(i.e. elle sert à éviter certaines erreurs de programmation)
 

*** Quelles compilations manquent?
**** La transformation en application concrète exécutable
S'il avait eu le temps, Ronan l'aurait faite en JavaScript pour
le côté client et en Scala pour le côté serveur.


**** La compilation vers proVérif
La compilation vers le pi-calcul a été faite
et il a été expliqué comment compiler vers proVérif, mais
le compilateur vers proVérif n'a pas été codé.


*** L'implémentation actuelle permet-elle de mettre en place des mécanismes de sécurité?
Elle permet de les décrire (c'est le principal but de C2QL)
mais puisque la compilation vers une application concrète n'existe pas
encore, elle ne les mets pas vraiment en place.


*** L'implém actuelle donne-elle de l'assurance?
C'est le but de la transformation vers proVérif, qui n'est pas automatisée


*** Est-il possible d'accéder au livre d'Ullman?
Oui, Ronan me l'a passé.


*** ACHTUNG dans les lois, parfois les conditions d'application ne sont pas écrites
Comme c'est le cas dans la loi de permutation de selection et projection,
empruntée à Ullman. (équation 5 page 30)


*** La fragmentation et le rapatriment côté client appelés "cryptographie"?
Oui, car ce sont des techniques rendentant inintelligible...
**** pour la fragmentation,
l'association de données
**** pour le rapatriment côté client,
les données... vis à vis d'un attaquant qui intercepterait les comunications
sur les canaux de comunication


*** Est-il vraiment nécessaire de prouver correction d'un point de vue privacité alors que cc dès que nécessaire?
Justement, lorsque pour une loi algébrique il est question de
prouver la correction d'un point de vue privacité, il s'agit de savoir
si la gestion des fragments / du côté client envisagée
préserve bien les contraintes... MAIS CETTE GESTION EST IMPLICITE


*** L'implémentation en Scala a été abandonnée
Car elle utilisait largement les types dépendants, qui ne sont
pas une notions native au langage ni aisée d'utilisation
en Scala (en effet, pour faire apparaître des types dépendants, il
faudrait forcer le compilateur à calculer des types à la volée en utilisant
les implicits).


*** Est-ce que Ullman définit une sémantique précise?



 Regarder le livre d'Ullman

 Il travaille avec une sémantique basée sur des produits cartésiens de domaines
 (donc sur des tuples).
 Il ne fait qu'évoquer la définition à base de fonctions d'attributs vers valeurs.

 C'est cette deuxième définition, qu'elle ne fait qu'évoquer, que j'ai retenue.




** Doutes / choses à voir
Idris plus adapté car manipule nativement les types dépendants


*** L'implémen actuelle permet-elle de définir une politique de sécurité?
Pas en C2QL, mais à priori oui, en Idris et proVérif
**** TODO regarder comment peuvent être définies les politiques de sécurité en Idris et proVérif


*** POSSIBLE Regarder les expérimentations de Ronan 
[[http://www.github.com/rcherrueau/C2QL/tree/master/experimentations][Dossier des expérimentations]]


*** Dans cryptDB
Est-ce que la partie "proxy" ne pourrait pas s'exécuter côté client
pour avoir un nuage confidentiel?




*** Avoir plusieurs encodages/chiffrements et séparer les filtres
comme en CryptDB, pourrait-ce être une extension?


*** p.77 => toute fonction autre que décrypt commute avec defrag??
Non, ici le critère de validité se base sur l'hypothèse
qui la requête en question a été optenue avec la méthode
suggérée dans la thèse (d'abord version locale, puis 
protection, puis lois).

Il reste cependant à 
**** TODO *vérifier* que toutes les commutations faites avec le defrag peuvent être défaites de façon transparente.


*** p.78 => mais il peut y avoir un destructeur pour un fragment sans qu'il y en ai pour l'autre, non??
Non. Pas si la requête est sous forme canonique... et qu'il n'y a pas de defrags imbriqués!
**** POSSIBLE Est-ce qu'on veut vraiment se limiter au cas où il n'y a pas de defrags imbriqués?


*** p.78: il parle d'un \vee, qui n'apparaît nul part dans las formules...
**** TODO poser la question
Le 23/06 à 13h30 j'ai rendez-vous avec Ronan, je pourrai lui poser la question

** Remarques



*** Le rapatriment des données côté client n'étant pas explicite
les différent mécanismes de préservation de la confidentialité n'ont
pas tous le même statut... (cc n'a pas le même statut que frag ou crypt)
Initialement, ceci est dû au fait qu'on peut le déduire
de la position des constructeurs et des destructeurs


*** On fait apparaître les constructeurs de confidentialité à chaque requête...
pourtant ils doivent être les mêmes pour tout le programme,
pour toutes les requêtes.
** notes personelles


*** zero-knowledge proof
Permet de certifier l'intégrité d'un calcul sans transmission de données

*** notions de Saas, Paas et Iaas
Dans les exemple avec deux fragments, nécessité de louer deux Iaas et un Paas
*** ? filtres de Bloom ?
*** pi-calcul
En bref: lambda-calcul concurrent
*** chiffrement homomorphe
Le chiffrement de Gentry est un 
chiffrement homomorphe total, qui permet tout type d'opérations,
est couteux et demande à ce que le chiffrement soit raffraichit assez
fréquemment. Raffraîchissement long.
Mais il existe de nombreux chiffrements partiellement homomorphes:
**** permettant l'addition
**** permettant la multiplication
Comme ElGamal
**** permettant le test d'égalité
Les chiffrements déterministes en sont un cas particulier
(exemple: AES)
**** préservant l'ordre
*** Lors de la fragmentation verticale
Si dans un fragment une donnée est chiffrée,
la clé peut être stockée dans l'autre fragment.
*** Def loi algébriques
Transformation correcte d'une querry en une autre...
Ici, permutation correcte de deux fonctions
*** Regarder du côté de diVimercati pour la fragmentation verticale
*** Dans le pi-calcul, l'opérateur new
est une restriction car il limite la visibilité des cannaux.
En imposant à un canal d'être frais, nouveau, il 
restreint l'ensemble des processus pouvant s'en servir

*** Attention, la traduction en pi-calcul ne traduit que la communication avec le cloud
et non pas ce que se passe chez chaque acteur
=> au moment de traduire vers proVérif il faudra le prendre en compte,
pour les decrypt, par exemple


* Optimiseur des requêtes
Il y a différentes choses à faire, dont
***** Calculer un schéma à partir d'un schéma et d'une expression C2QL
***** Calcule-t-on toutes les transformations possibles?
***** Comment choisi-t-on entre deux transformations


* Carnet de bord à partir du 12/06
** 12/06
Je vais plutôt commencer à démontrer les lois,
et je finirai d'énoncer les lois pour le fold après

Un des enjeux va être de trouver une façon efficace de régiger
les démonstrations, vu qu'il y en aura plus de 40...

*** Question que je me pose: Comment regrouper/ordoner les lois?
Le regroupement peut se faire par opérateur (proj, selections, ...)
ou par catégorie (qui relève des calculs locaux, qui relève du chiffrement,
qui relève de la comunication entre acteurs...).

Le regroupement par opérateurs me semble plus objectif, mais moins attrayant.

*** Projection et défragmentation
Pour pouvoir passer de droite à gauche dans cette loi, il est 
nécessaire de supposer que les schéma relationnels en entrée ont une intersection vide!

À nouveau deux possibilitées s'offraient à moi:
+ soit je passait d'une notion d'équivalence à une notion de transformation
pour pouvoir avoir dans un sens, une loi qui suppose moins d'hypothèses
+ soit j'impose une hypothèse sur les schémas relationnels en entrée.

À nouveau j'ai conclut que la deuxième possibilité était la meilleure
car de toute façons:
+ Dans le sens où on pourrait se passer de l'hypothèse sur les schémas,
elle est quand-même présente, dans le fait que l'expression écrite soit définie
+ On dispose des schémas relationnels des entrées

(Ce n'est qu'après avoir fait ce raisonnement que je me suis souvenu
que je l'avais déjà fait).

N'empêche,
j'avais pas vu la nécessité de préciser cette hypothèse dans cette loi-là,
donc je vais pouvoir *corriger la loi en question*.

**** Devrais-je informer Ronan, Fatima et Mario de la modif à appliquer à la loi 12? 
Je verrai ça cette après-midi avec Mario.


** 13/06
Aujourd'hui, il serait important d'alterner entre
+ Démonstrations
+ Lois pour le fold
+ Relecture
Je me propose moi-même des blocs de 40 minutes
pour les deux premières activités, et de 20 minutes
pour la troisième.

*** Pour avoir une trace de ce que j'ai fait aujourd'hui
Voir les commits sur le git

*** re-lecture des définitions jusqu'à Agrégation
*** Pour l'intéraction groupe/fold... les deux sens se comportent pareil, malgré ma première impression
Si des éléments sont les mêmes leurs immages par une fonction sont les mêmes également,
mais pour faire la déduction inverse il faut que la fonction en question soit injective.

À cause de ça, l'intéraction entre fold et group (dans le cas où l'attribut reduit
est un des attributs sur lesquels porte le regroupement) ne se comporte pas de la même
façon qu'on aille dans un sens où dans l'autre, car 
dans l'un des deux sens l'hypothèse "f injective" est nécessaire.
Et cette fois ce n'est pas une hypothèse qui soit cachée dans le fait
que les quantités soient définies au départ...

J'ai rien dit... Dans les deux cas on a besoin d'une fonction injective car sinon
dans l'un des deux sens on serait en train d'agrandir les groupes du regroupement,
et dans l'autre sens on serait en train de les réduire.


** 14/06
*** Objectifs de la journée
Démontrer au moins 10 des 36 lois qu'il reste à démontrer
+ Mettre par écrit contre-exemple loi 12 thèse et l'envoyer
*** Problème qu'il faudra résoudre
[[*Les identifiants post-jointure ne sont pas des identifiants][Les identifiants post-jointure ne sont pas des identifiants]]
*** Bilan de la journée
+ La formulation des lois pour le fold est finie :-D
+ Finalement la loi (6) de la thèse est correcte,
mais il faudra adapter la condition aux nouvelles définitions
+ Démonstrations faites: 1 :-/


** 15/06
*** Objectifs de la journée
+ Faire au moins 21 démonstrations xD
+ Commencer à comprendre l'implémentation en Idris

*** Bilan de la journée
**** Correction de la définition de l'agrégation
Les différentes lignes d'un même group n'ont pas à avoir le même identifiant,
sinon la plupart du temps le group ne ferait rient et perdrait de son intérêt.


**** Définition de nom de groupe minimal
Dans les définitions de l'agrégation pour pouvoir parler d'unicité.


**** Harmonisation du nom des résultats dans les démonstrations
Maintenant tous les résultats s'appellent res_1 et res_2,
indépendamment du nombre d'arguments des fonctions considérées.


**** Démonstrations
+ De proj+group
+ De proj+fold_projeté
+ De proj+fold_non_projeté
+ sélection et sélection


** 16/06
*** Objectifs de la journée
**** Finir de corriger def defrag
**** Faire le plus de démonstrations possibles
A l'idéal 30 x)
**** Commencer à comprendre l'implem en IDRIS
*** Bilan de la journée
**** Fin correction defrag
**** Lectures
+ de The morning paper
=> J'ai l'impression que,
avec C2QL, on ne donne pas vraiment accès au
moteur de requêtes vu que justement, lors de la formulation du
programme toutes les requếtes possibles sont déterminées, et
ce n'est pas l'utilisateur comme tel, mais le compilteur en quelque
sorte qui les fait.
Ça c'est un bon point pour la sécurité :)

=> Le chiffrement déterministe, qui est très utile pour certains motifs de requêtes,
peut révéler pas mal d'informations sur les données => Chiffrer quand même la
communication entre les différents acteurs ne me semble pas être en trop..
**** Démonstrations
+ Sélection et défragmentation
+ Sélection et déchiffrement non sélectif
+ Sélection et déchiffrement sélectif
+ Sélection et défragmentation
+ Sélection et agrégation
**** Changement defs
***** Jointure
Pour que la sélection puisse commuter plus facilement,
on se permet de faire disparaître des deux côtés les lignes
n'ayant pas de correspondant dans l'autre table.
***** Attribut
[[*Changer les définitions pour que id ne soit pas un attribut][Changer les définitions pour que id ne soit pas un attribut]]
Je vais spécifier que id ne peut pas être un attribut,
et spécifier au cas par cas quand il peut apparaître avec d'autres
attributs.


**** Questions à se poser au-delà
***** L'optimisation des motifs peut ne pas être sûre car:
Les agents entre lesquels circule l'information et la
quantité d'information qui circule peuvent révéler
quelle est la requête qui est en train de s'

**** Choses à faire qui sont apparues
***** DONE Changer les définitions pour que id ne soit pas un attribut comme les autres
Fait. id est un attribut, mais pas un attribut régulier.
***** DONE Placer la def de chiffrement compatible ailleurs que dans les démos
***** TODO modifier les mentions de c=>p
par c_\alpha => p
**** Remarque: claviers Apple inutilisables dans les systèmes sensibles
La mauvaise détection de quand répéter une touche peut lancer / continuer
des commandes accidentellement, et ça peut avoir comme conséquence,
par exemble, la suprésion accidentelle de fichiers


** 17/06
*** Objectifs de la journée
Déménager x) (C'est un samedi)
*** Bilan de la journée
**** Démonstrations
+ Sélection/réduction
+ Fragmentation et défragmentation


** 19/06
*** Objectifs de la journée
**** Regarder puis ajouter group/fold à l'implémentation hydris
**** Choisir l'extension à faire / la suite du travail
*** Première lecture du code idris
**** Qu'est-ce que privy??
Privy est "l'implémentation" de C2QL en ce sens
qu'elle calcule ce qui arrive concrétement aux schémas,
pour vérifier qu'il n'y a pas d'erreur de composition/typage.

Privy plus expressif que C2QL??

**** Pour rajouter un opérateur
Il faut, AU MOINS 
+ Le rajouter dans la déclaration du type C2QL
+ Le rajouter dans la fonction d'affichage
+ Rajouter le test d'égalité associé
+ Le rajouter dans privy et dans l'interprétation de C2QL en Privy
*** Bilan de la journée
**** Instalation de idris, ghc, gmp, cabal etc
**** Exécution du code idris
Réussie
**** Comparaison des définition formelles avec les definitions idris
La gestion du count dans l'implem ne semble pas 
aborder tous les cas de figure possible.

Je suis en train de
***** comprendre le statut des objets/fonctions tels que DEFRAG
Defrag est le constructeur des objets de son type (cf. case class en Scala)

***** En ce qui concerne proj
+ La projection se fait bien sur un ensemble de termes :D
+ Pour l'instant je n'ai pas l'impression que cet ensemble puisse ne pas être inclu dans le reste :/

**** DONE Vérifier qu'il y a toutes les lois pour enlever les opérateurs qui n'agissent pas


** 20/06 et 21/06
*** Objectifs des journées
**** Définir la prochaine étape
+ Quelle extension faire?
+ Quel est son intérêt de recherche?

[[*Prochaine étape][Prochaine étape]]

**** DONE Poser des questions à Ronan sur son code
Je viens de voir qu'une partie des réponses étaient dans les sections 5/6 de sa thèse,
que je vais donc lire
***** Qu'est-ce que Privy?
***** Qu'est-ce que Hole_ (: Nat -> C2QL) ?
***** Notation auto et notion d'environement

**** Relire/corriger définitions sémantiques
Les principaux changements qui ont été faits 
sont présents [[*Relecture des définitions][ici]]

**** Commencer l'optimiseur de requêtes
Mon but pour l'instant est de le faire en tant que fonction dans Idris


*** Bilan des journées
**** Prochaine étape 
Je vais commencer par faire un programme qui tienne
compte des lois et des préférences du développeur pour
optimiser la requête.

Ceci a été fait pour les requêtes sur des bases de données normales,
mais pas pour les requêtes tenant compte d'une composition
fragmentation verticale / cryptographie.

**** Implémentation C2QL
***** Modification de ce que sont les attributs
La modification pour qu'un attribut puisse être un liste d'attributs
(cf. définition sémantique de group)

***** Introduction du fold et du group

**** Relecture des définitions
***** DONE id pas un identifiant comme les autres
+ ça permet une définition plus propre de "schéma"
+ ça change la définition de S
+ et ça nécessite de rajouter des "régulier(s)" un peu
partout où il y avait écrit "nom(s) d'attribut(s)"
***** DONE valeurs stables par liste
***** DONE assurer l'unicité des identifiants
+ ça change la définition de l'identifiant pour la concaténation
lors de la jointure naturelle
+ et la définition de ligne de groupe pour l'agrégation
+ et ça rajoute une condition à la défragmentation horizontale 

**** Réunion avec Mario


** 22/06
*** Objectifs de la journée
**** Optimiseur de requêtes
***** Dresser un tableau de qu'est-ce qui est optimisé par chaque loi
***** Écrire une fonction schéma
Qui, donnée une expression C2QL et une liste de schémas, en calcule le schéma résultant
**** Compréhension de l'implémentation
Lire les chapitres 6 et 7 de la thèse de Ronan pour comprendre
+ Ce qu'est Privy
+ Les choix qui ont été faits pour l'implémentation
**** Relecture/complétion des démonstration
+ Commenncer à relire les démonstration
+ S'il y a le temps, faire la démonstration suivante

*** Bilan de la journée
**** Compréhension de l'implem / lecture des chaps 6 et 7 de la thèse de Ronan
+ Des exemples sont cités d'erreurs que l'implem idris permet d'éviter
=> [[*Pour reproductibilité: vérifier erreurs evitées][Pour reproductibilité et compréhension: vérifier erreurs evitées]]

+ ADT :: Algebraic Data Type... Pour l'instant j'ai juste l'impression que ce serait
l'équivalent / un cas particulier de Case Class en Scala; à voir

+ total :: Fonction considérant tous les cas dans les pattern matching
et agissant systématiquement sur des structures strictement plus petites
lors des appels récursifs
Dans une définition d'un type (dépendant) toute fonction intervenant dans la
définition du type *doit être totale* ce qui donne une garantie de calculabilité du type
au type-checker

+ Type :: est le type des types
(et est utilisé, entre autres, pour déclarer un type de base)

+ Être paramétré par un type :: revient à prendre un type en paramètre,
donc à être une fonction (et donc, en autres, un type peut être une fonction
{car un type peut être paramétré par un autre})

+ Des accolades :: permettent d'indiquer un type-paramètre comme implicite, pour
que le type-checker le déduise du contexte quand possible

+ Article de Swierstra :: qu'il peut être utile de lire 
The power of pi 2008 ACM
[[file:ThePowerOfPi.pdf][Oury&Swierstra2008]]

+ ACHTUNG Le fait qu'une lettre soit minuscule ou majuscule ::  dans un argument de type change le sens
En effet, les minuscules indiquent pas elles mêmes un caractère implicite

**** Modifications à l'implémentation Idris
***** Pourquoi les predicats devraient être paramétrés par un type?
****** DONE Première idée de comment je pourrai le savoir:
Je vais enlever tous les BOOL des pred et regarder si ça marche encore x)

ça fonctionne encore! J'en déduis pour l'instant (jusqu'à demander à Ronan demain)
qu'il n'y en avait pas besoin.

***** DOING Alléger les contraintes sur le domaine du prédicat
En effet, on peut vouloir faire des OR et des AND sur des prédicats ne portant pas
sur les mêmes variables (qui donne pour résultat un prédicat sur l'union des domaines).

Mais surtout, on peut vouloir commuter une sélection sans avoir à changer le prédicat, non?

Je viens de décider que je vais apprendre à me servir d'Idris avant de continuer de modifier le code xD

***** DOING frag ne rend pas une expr C2QL, mais 2.. non?
J'ai modifié le type de frag, ce qui va provablement nécessiter 

**** Apprendtissage d'Idris
Comme suggéré par Ronan, je vais étudier par la réécriture la définition des listes
qui est donnée par le langage (qui, parait-il, utilise les preuves)

*** Choses à faire qui son apparues
**** TODO Pour reproductibilité et compréhension: vérifier erreurs evitées
Déclarer les faux-programmes qui servent d'exemple dans la section 6
 en C2QL et vérifier que ça déclenche bien une erreur de typage
**** TODO Possibilité d'encoder des schémas comme des ensembles
En utilisant, si nécessaire, cette implémentation d'ensembles en Idris
[[https://github.com/jfdm/idris-containers/blob/master/Data/AVL/Set.idr][Implem d'ensembles en Idris, par l'un des développeurs d'Idris]]

Ou plutôt en utilisant Data.Fin? 
[[http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html][cf "The finite sets" here]]
Non, c'est des ensemble canonique, pas des ensembles arbitraires


** 23/06
*** Objectifs de la journée
**** Reproductibilité
Vu que c'est dans Privy et non pas dans C2QL
qu'il faut vérifier la reproductibilité des erreurs pour les mauvaises expressions,
il n'y a pas besoin d'utiliser les Hole_ : Nat -> C2QL    :-D
**** Compréhension du code de Ronan
Réunion à 13h30
**** Tableau d'optimisations effectuées par chaque loi
**** Suite de la lecture des chapitres 6 et 7
*** Choses qu'il restera à faire
**** TODO Modifier frag pour qu'il rende (C2QL, C2QL) et non pas C2QL
*** Bilan de la journée
**** Réproductibilité
+ Les erreurs ne sont lancées que si on formule la requête avec Privy,
et non pas avec C2QL (c'est normal, cf [[*Réunion avec Ronan][Réunion avec Ronan]])

+ FalseEnv1 (corresp ex 2 p105) échouait pour la mauvaise raison
mais il échou correctement après correction :-)

+ FalseEnv2 échouait pour la mauvaise raison, et n'échoue plus après correction :-/

+ falseSpecFragLeft semble échouer correctement,
mais je n'ai pas compris quelle partie de la notation spécifie sur quel fragment s'effectue la deuxième op

+ falseSpecCrypt échou correctement :)

**** Réunion avec Ronan
***** Choses que j'ai compris
****** C2QL is not intended for use, Privy is
C'est Privy qui est fait pour être utilisé pour la description des compositions.
C2QL a été fait pour une utilisation interne à des buts de pi-calcul


****** Le rôle du handler, l'existance et le sens du bind, monades
Handler comme lien avec le monde réel; construction connue

 *bind* comme dans l'exemple
Si x est un IO a 
et f est une a -> IO b
alors 
y <- a
f y
est un IO b, qu'on peut rebinder

Autrement, le >>= fait deux en un: il extrait la partie
intéressante et applique sur ce qu'il a extrait

Et, de façon assez drôle,
le Return (ou Pure) est.. *le point d'entrée* à la monade x)

Car oui, si on défini un bind et un return, ça définit, en Idris, une monade
****** TODO Regarder plus précisément ce qu'est une monade
Ronan conseille de regarder la monade State


****** Le sens du point et du dolar
Le point est vraiment une composition fonctionnelle

Le dolar est un acteur sintaxique pour dire "d'ici jusqu'à la fin, c'est une seule valeur / un seul argument"
Il donne la priorité d'évaluation à ce qui est à droite du dolar


****** Il y a une libraire SQLite pour idris
Faite par
[[https://github.com/david-christiansen/IdrisSqlite][David Christiansen]]


***** En quoi ça change mes objectifs
+ C'est normal que les requêtes fausses exprimées en C2QL ne lèvent pas d'erreur
(car c'est lorsqu'elles sont exprimées en Privy qu'elles lèvent des erreurs)

+ Par contre je devrai être maintenant en mesure de comprendre les erreurs qui doivent
être levées en Privy, et vérifier qu'elles sont bien levées

+ Si un jour je veux implémenter / aider à implémenter concrètement C2QL
[[*Il y a une libraire SQLite pour idris][Il y a une libraire SQLite pour idris]]


***** Miracles que j'ai envie de faire
****** Former un terme Privy à partir d'un terme C2QL
****** Remplacer le plus de dollars possibles par des points
****** Dans C2QL.. Séparer description des tables, des contraintes, et des requêtes?


** 26/06
*** Objectifs de la journée
**** Optimiseur
+ Dresser la liste d'avantages
+ Dresser le tableau d'avantages par lois

**** Faire un schéma explicatif du fonctionnement du code Privy
*** Bilan de la journée
**** Squelette démos
Le fichier de démonstrations a été complété avec toutes les lois
(quitte à, pour la fin, n'avoir que le squelette)
et l'ensemble des lois a été renuméroté,
pour suivre l'ordre du tableau de complétude.

**** Optimiseur
***** Liste des critères
Les critères selon lesquels il faut évaluer les effets des lois sont
+ Augmentation de l'utilisation du cloud (abrégé C)
+ Amélioration du temps de calcul        (abregé T)
+ Diminution de l'utilisation réseau     (abrégé R)

***** Tableau des effets
Le tableau de comment les différentes lois influent sur ces différents critères
est en train d'être dressé:

(Dans ce tableau on considére les effets du passage du membre gauche de la loi
vers le membre droit; le passage inverse ayant les effets opposés.

|      Loi | effets        |
|----------+---------------|
|        1 | +T            |
|        2 | -T            |
|        3 | +C +R         |
|        4 | +C +R         |
|        5 | +C +R +T      |
|        6 | +T            |
|        7 | -T            |
|        8 | Implem proj   |
|        9 | ++T           |
|       10 | +T            |
| 11 et 12 | +T +C +R      |
| 13 et 14 | +T +R +C      |
| 15 et 16 | +T            |
|       17 | -T            |
|       18 | +T            |
|       19 | spé           |
| 20 et 21 | Cons          |
| 22 et 23 | Cons          |
| 24 et 25 | Cons          |
| 26 et 27 | Neutre        |
| 28 et 29 | -T -R +C      |
| 30 et 31 | +C +R -T      |
| 32 et 33 | +C +R         |
|       34 | Neutre        |
|       35 | Spé           |
|       36 | Neutre        |
| 37 et 38 | -C            |
|       39 | +C +R         |
|       40 | +C +T +R      |
|       41 | +C +R         |
|       42 | +C +R ?T      |
|       43 | Impredictible |
|       44 | +T            |
| 45 et 46 | +T            |
|       47 | Dépend        |
|       49 | +T en général |
|       50 | Neutre        |
***** Code idris
J'hésite entre utiliser la monade Privy (qu'il faudrait donc comprendre)
ou essayer d'utiliser plutôt C2QL quittre à refaire le calcul du schéma actuel

** 27/06
*** Objectifs de la journée
**** Code Idris de l'optimiseur
*** Réflexions de la journée
**** Avec structure, mais sans trous
Dans l'ADT C2QL, il y a la traduction de la structure
presque arborescente (en réalité c'est une structure de 
graphe *orienté* connexe acyclique, et non d'arbre)
mais il y a des trous.

Mon but avec les ADT Fonction et Formule,
je veux traduire cette structure presque arborescente,
sans utiliser de trous.

Ce qui nécessite de prendre en compte l'arité des résultats
lors de la construction de la structure.
