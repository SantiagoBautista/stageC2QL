* Grandes lignes
** Définir une notion de complétude pour les lois algébrique
*** Première idée: 
[[*Première idée de critère de complétude][Complétude formelle: exprimer toutes les requêtes équivalentes]]

Intuition: J'ai l'impression que pour que ce critère de
complétude puisse être sattisfait, il faudrait créer des nouvelles
lois identité, pour pouvoir faire apparaître au besoin toutes les différentes
fonctions dont peut être composée une requête C2QL


*** Deuxième approche:
Moins formellement, on peut garder la même approche que Ronan et vérifier si
+ Les catégories de lois qu'il propose comprennent toutes les transformations
qu'on peut vouloir faire
+ Chaque catégorie est complète


*** Troisième approche
Vu que toutes les lois algébriques de C2QL s'intéressent à la composition,
voir à la commutativité, de différentes fonctions,
une troisième approche serait de 
dresser un *tableau* pour toutes les composition de deux fonctions de C2QL.


** Établir la correction des lois algébriques
*** Correction sémantique
Pour la correction sémantique d'une loi algébrique on peut prendre
pour définition celle qui à priori est la définition d'Ullman (82) :
Deux fonctions sont sémantiquement équivalentes si elle coïncident
sur l'ensemble de toutes les relations, indépendament du schéma relationnel

Pour démontrer la correction sémantique, il me semble que la seule chose
qui peut s'avérer gênante est la présence de comportements *implicites* dans
les lois fournies. En effet, la loi (20) par exemple [page 66 de la thèse]
nécessite d'une synchronisation/séquentialisaiton des calculs effectués
sur chacun des deux fragments pour être juste.
Cette synchronisation est un effet de bord, qui n'apparâit pas 
dans l'écriture de la requête comme composition de fonctions
(parce que de fait, les fonctions du langage C2QL ne sont pas des fonctions
pures).

Il a été mentionné qu'une extension possible serait de rendre *explicite* 
dans C2QL la gestion des deux bases de données / clouds distinct(e)s...
Si cela est fait, l'information transmise d'une DB à l'autre serait
de ce fait rendue explicite (et donc en particulier la synchronisation
nécessaire pour la tranformation (20) serait explicite) et cela
résoudrait la gêne que j'ai exprimé précédemment.

*** Correction de l'équivalence de confidentialité
Le mantient de la confidencialité, lui aussi, repose grandement
sur des mécanismes potant sur
- le rapatriment des données côté client
- la nature des informations transmises à tel ou tel fragment de la base de données
Prouver que les transformations préservent la confidentialité pourrait donc
également être facilité par l'introduction explicite de la genstion
des diférents clouds et des comunications entre les différents agents.
Dans le travail déjà effectué, cette introduction a surement lieu lors de la traduction
en pi-calcul.


** Extensions possibles

*** Plus de deux fragements
Actuellement les fonctions de fragmentation/défragmentation
sont faites pour fragmenter/défragmenter en/depuis 2 segments.
Une idée pourrait être de généraliser ces fonctions pour
travailler avec un nombre quelconque de segments.


*** Plus d'un utilisateur
Pour le moment, le langage a été construit en considérant qu'il y a
un seul utilisateur du service à la fois, "Alice".
Faudrait-il étendre le langage pour gérer plusieurs utilisateurs qui
utilisent la ressource au même temps?


*** Autres propriétés de sécurité que Privacité
En ce moment, le langage permet au développeur
de réfléchir sur comment il va composer les
mécanismes de sécurité pour préserver la privacité/confidentialité
des données.
On pourrait introduire également dans le langage des mécanismes
permettant de préserver d'autres propriétés de sécurité,
telles que *l'intégrité*, par exemple.


*** Faire apparaître dans le langage la répartition entre plusieurs clouds
En ce moment, la gestion des différents clouds (nécessaire pour la
gestion correcte de la fragmentation) est faite implicitement,
et manuellement.
Des idées pourraient être soit de l'automatiser (en fonction des contraintes
de privacité, suggérer une répartition qui marche) soit de la rendre
explicite dans le langage.


*** Si ce n'ai déjà fait, généraliser avec group/fold au lieu de count
Dans la thèse, toutes les lois sont exprimées avec count
Un langage disposant des fonction group et fold étant plus expressif
qu'un langage ne disposant que de count,
je trouverai ça intéressant de, si ce n'est déjà fait,
intégrer complétement les fonctions group et fold au langage.


** Autres

*** Compilation vers proVérif
En ce moment, la transformation vers le pi-calcul
est codée, mais pas celle vers proVérif.
Coder la transformation vers proVérif
permettrait de vérifier automatiquement la correction
des programmes codés en C2QL


*** Modifications visant à simplifier les preuves
Si nécessaire, il est possible de modifier le langage
pour faciliter les preuves



* Choses à faire (dans l'immédiat)
** C2QL
*** S'intéresser à la complétude du système de lois algébriques
**** Faire la liste des lois algébriques
J'ai réuni dans un seul endroit toutes les lois, reformulées
[[file:lois/ensemble_lois.pdf][Ensemble des lois]]

***** DONE Demander à Ronan le code tex
Si je peux avoir le fichier .tex de la thèse ou de l'article,
cela m'éviterait de devoir taper de 0 toutes les loi

***** DONE Regrouper les lois apparaissant dans la thèse 
[[file:lois/ensemble_lois_these.pdf][Ensemble des lois apparaissant dans la thèse]]
Emplacements de référence des différentes lois dans la thèse: pages 30 et 63


***** DONE Regarder si elles contiennent les lois apparaissant dans l'article
Non.
+ Dans l'article les lois sont formulées en thermes de group et non de count
+ les lois de sélection sont plus rigoureuses (domaines <- selec sur plus
d'un attribut à la fois)
+ Il y a à la fois de la fragmentation verticale 
et de la fragmentation horizontale
***** DONE Choisir quel ensemble de lois garder initialement
****** DONE Se familiariser avec les macros LaTeX / en créer des propres
******* projections
\pi_{\delta} suffit
******* sélections
\sigma_p suffit
******* frag, defrag, crypt et decrypt
Je vais déclarer des opérateurs amsmath
******* group/fold
Je trouve plus pertinent de travailler avec les fonctions
group et fold, plus générales, que avec la fonction count, qui est
un cas particulier.

\mathrm{group}_{delta}
\mathrm{fold}_{f, z}
****** DONE Faut-il garder la fragmentation horizontale?
Pas nécessaire d'écrire toutes les lois, juste la mentionner
****** Garder les lois de projection de la thèse, pas de l'article
Les définitions avec les intersections sont plus claires et probablement
plus justes que les distinctions a/aBarre


**** Définir une notion de complétude du système de lois
***** DONE Première idée de critère de complétude
Vu que l'objectif de C2QL est d'aider le développeur
à composer les mécanismes de sécurité de sorte à optenir un système
sûr, efficace et nuagique, pour l'instant il me semble que la notion de complétude
qu'il serait le plus intéressant de vérifier est:

À partir d'une requête C2QL, l'ensemble des lois
permet-il d'exprimer toutes les requêtes
étant sémantiquement équivalantes à la requête initiale?

Si cette propriété de complétude était vérifiée, on serait sûrs de pouvoir
optenir la requête la mieux optimisée, quel que soit le critère d'optimisation.

***** DONE Deuxième approche du critère de complétude
[[*Deuxième approche:][Complétude informelle: ensmb des catégories, et catégories elles-mêmes]]

***** DONE Lire Ullman pour réfléchir à la pertinance des critères
Peut-être Ullman définit-il un autre critère de complétude pour
l'ensemble de ses lois? Peut-être définit-il ce critère-ci et le
prouve pour son ensemble de lois?

Non. Ullman ne se soucie pas de complétude.

***** DONE Troisième approche: Toutes les compositions 2 à 2
Le but de toutes les lois algébriques est de, par permutation,
permettre une optimisation de la requête exécutée.

On serait du coup sûrs d'avoir explorée complétement
cette approche si *pour toute paire de fonctions C2QL* on
a une loi décrivant la possibilité, les conditions et
le résultat d'une permutation entre elles.

***** DONE Chercher dans Supernova (Univ Rennes 1) article sur la complétude
Le plus proche que j'ai pu trouver est un article d'économie sur
la modélisation mathématique de, grosso modo, le pouvoir d'achat
des ménages...
[[file:completude_economie.pdf][Systèmes complets de fonctions de demande]]


**** Vérifier si le système de lois vérifie le critère de complétude
***** Pour la première approche: échec 
Le formalisme que j'ai essayé d'introduire pour démontrer la complétude de
manière formelle peut être trouvé ici:
[[file:completude/premiere_tentative.pdf][Première tentative de complétude]]
****** Remarque: c'est aussi une histoire de complétude au sens de la logique! 
En logique, on a des systèmes de déduction qui, opérant sur la syntaxe, permet,
à partir d'un ensemble initial de formules, de déduire d'autres formules.
Lorsqu'on a un système de déduction, on s'intéresse à deux choses:
+ La *correction* du système de déduction
Si on peut déduire une formule F' à partir d'une formule F,
est-ce que F' est conséquence *sémantique* de F?
+ La *complétude* du système de déduction
Si on a une formule F' qui est conséquence sémantique d'une formule F,
peut-on déduire F' à partir de F?

Vouloir démontrer la complétude du système de lois telle que formulée
initialement revient à vouloir montrer qu'avec les régles de déduction
correspondant aux lois algébriques que l'on a, on peut déduire toute
tautologie de l'ensemble de formules vide.

C'est donc aussi un problème de complétude au sens logique du terme.

***** DONE Pour la deuxième approche
Il manque des lois pour le fold, une des lois pour crypt, etc...

***** DONE Pour la troisième approche
 Tableau des lois existant actuellement + \crypt\circ\defrag
[[file:completude/fait.pdf][Etat de la complétude dans la thèse au sens de la troisième approche]]


**** Compléter le système de lois
Ceci sera fait pour la troisième approche,
la première étant probablement impossible et la deuxième
étant contenue dans la troisième.

***** TODO Dresser et *compléter* le tableau de lois de commutation
[[file:completude/nouveau.pdf][Etat actuel de la complétude au sens de la troisième approche]]



*** Remplacer count par group/fold...
**** ... dans les lois
***** DONE Prendre les lois de group de l'article, plutôt que les lois de group
***** TODO ajouter des lois pour le fold
**** TODO dans l'implémentation actuelle de C2QL


*** Sémantique des fonctions et des formules
**** Définir la sémantique des fonctions utilisées
En justifiant les choix faits, en particulier dans leurs
différences avec ce qui existe actuellement

**** Démontrer la correction sémantique des lois




** ORGanisation
*** DONE Passer mes notes en ORG mode
Fait :-)
[[*Prise de notes][Prise de notes]]


*** DONE Créer un dépôt git
[[https://github.com/SantiagoBautista/stageC2QL.git][Dépôt git du stage]]



* Erreurs trouvées
** Composition de plusieurs projections
(p. 30 de la thèse) Projeter sur plusieurs sous-ensembles
en cascade revient à projeter sur l'intersection, et non sur l'union

Pour la sémantique qu'il donne à \pi_{a_1, ..., a_n},
voir exemple page 29 ou définition page 28

*** Contre-exemple 
Si on considère la relation r suivante
| a_1 | a_2 |
|-----+-----|
| a   |   1 |
| b   |   2 |
son image par $\pi_{a_2}$ est
| a_2 |
|-----|
|   1 |
|   2 |
dont l'image par $\pi_{a_1}$ est la table vide

Ainsi, l'image de r par
$\pi_{a_1} \circ \pi_{a_2}$ est la table vide.

Par contre, l'immage de r par
$\pi_{a_1, a_2}$
est la table r elle-même,
qui est différente de la table vide.

Ainsi donc, la loi (3) à la page 30 de la thèse est fausse.





** Chiffrement et sélection
Dans l'article, pour les lois (14) et (15),
la discussion ne devrait pas porter sur dom(p)\in\P(a)
mais sur dom(p) \cap a = \emptyset
*** En fait, cela a été  corrigé dans la thèse
Mais la formulation de la correction ne me semble pas la bonne


*** Contre-exemple
On prend pour prédicat p 
p: a_1 + a_2 < 10

pour fonction de chiffrement s
s: n |-> n+50

et pour ensemble des attributs chiffrés a
a: {a_1}

Le domaine de p est alors {a_1, a_2}
qui n'est pas une partie de a.
On est donc dans les hypothèses mentionnées
dans l'article pour la loi (14)

On s'intéresse à la relation r
| a_1 | a_2 |
|-----+-----|
|  51 |   2 |

L'image de r par
$\sel_p \circ \decrypt{s}{a_1}$
est la relation
| a_1 | a_2 |
|-----+-----|
|   1 |   2 |

L'image de r par
$\decrypt{s}{a_1} \circ \sel_p$
est la relation vide.

Ainsi donc, la relation (14)
dans l'article est fausse.
(Car la condition donnée n'est pas assez restrictive)

Inversement, la loi (15), qui est là pour être appliquée
lorsque la loi (14) ne s'applique pas, est, dans l'article,
trop restrictive.



* Choix dans les définitions
** Définition sémantique de "relation"
Dans un premier temps, j'ai voulu définir une relation juste comme la table de ses valeurs.
Mais cela me posait le problème suivant:
une même relation pouvait correspondre à des schémas relationnels différents...
alors qu'en soit une relation n'a qu'un seul schéma relationnel...

Dans un deuxième temps, j'ai voulu définir une relation comme un couple de
schéma relationnel et de table des valeurs,
mais avec cette définition, la formalisation de ce qu'est une projection n'était pas
naturelle, les attributs n'apparaissant pas vraiment dans la table.

C'est alors que dans un troisième temps j'ai compris l'intérêt de la deuxième définition
d'Ullman: une relation est un ensemble de fonctions.
La notion de fonction encapsule efficacement et synthétiquement à la fois 
cette existence et unicité du schéma relationnel, et cette idée de valeurs.


** Définitions relatives à la jointure et la fragmentation
Les notions intermédiaires que je souhaitait introduire pour la
défragmentation et pour la jointure étant très proches
(unificateur, lieu d'unification, concaténation...)
cela semblait confus de leur donner des noms différents...

C'est pour cela que j'ai choisi de voir la défragmentation comme un cas particulier
de jointure.
*** Problème qui se pose : indentifiants pour les jointures naturelles
Doit-on imposer que l'identifiant fasse partie des attributs communs (égaux)?

A priori non, car on peut vouloir faire une jointure où l'un des membres serait
issu d'un calcul (d'une opération d'agrégation) que l'on voudrait rajouter à l'autre
membre...

Mais alors à l'issue de la jointure on pourrait se retrouver à
+ avoir des identifiants qui n'ont pas de sens vis à vis
du reste du système
+ / ne pas avoir d'identifiant
+ / devoir choisir entre différents identifiants
??
**** Lorsque les identifiants ne coïncident pas, tous les choix me semblent arbitraires 
Pour l'instant je choisis donc de garder l'id de gauche,
mais je vais investiger dans quels cas ça pourrait raisonnablement
se produire, pour voir quel est le choix raisonnable dans ce cas là.
**** TODO Chercher un exemple où il faut accepter IDs différents
Eventuellement, chercher parmi les exercices classiques d'enseignement du SQL
**** TODO Chercher un exemple où ça serait gênant de perdre les identifiants
Typiquement, un exemple où il faudrait faire une défragmentation après une jointure
*** Lieu de jonction vs attributs en commun
Si on définit la notion de lieu de jonction,
que faire avec des attributs communs qui n'auraient pas la même valeur?


** Définition de l'aggrégation
Pour l'instant le choix que j'ai fait lorsqu'on regroupe
est de faire apparaître les listes des différentes valeurs
pour les attributs ne faisant pas partie des attributs de regroupement.

Cependant, ceci n'est pas ce que fait SQL:
pour les attributs n'ayant pas servi à regrouper,
SQL ne permet que d'afficher des fonctions sur l'ensemble des valeurs.

Mon approche à moi est plus modulaire/fragmentaire/fonctionnelle
en ce qu'elle permet de raisonner sur les effets de la fonction \group seule
et après de la composer avec les autres fonctions, dont fold notament.

Mais mon approche ne semble pas naturelle: dans la définition sémantique
elle nécessite l'introduction de beaucoup trop de couches de concepts intermédiaires,
dont une que je n'arrive pas à nomer: celle qui construit une ligne du résultat
à partir des valeurs de groupe


** La notion d'équivalence n'est pas forcément la bonne
En réalité il s'agit de transformations, qui 
(du point de vue d'un ordinateur aveugle)
ne se comportent pas pareil
selon qu'on les applique dans un sens ou dans l'autre.

En effet, dans le cas de join et défrag, defrag \circ \Join
peut toujours être transromé en \Join \circ \defrag, mais 
l'inverse n'est pas toujour vrai.
C'est aussi le cas des lois 3, ...

Non non non, en soit, il y a pour certains lois des sens
pour lesquels il semblerait qu'on peut se passer de la condition..
mais c'est seulement parce qu'on a la condition dans une autre hypothèse
(à savoir "l'expressioin d'origine a du sens") donc
en vrai on est pas vraiment en train de se passer de l'hypothèse...

Donc la notion d'équivalence était bel et bien la bonne


* Problèmes dans mes définitions
** Définition de la jointure ne correspond pas avec jointure naturelle
La définition SQL comme la définition d'Ullman (produit cartésien puis filtrage)
concordent entre elles et ma définition ne correspond pas.

Serait-ce finalement une bonne idée de travailler avec le produit cartésien?

Après recherche d'exemples d'utilisation de la jointure pour des bases de données
réelles, je m'apperçoit que ma définition convient :-)


** En fait, les schèmas relationnels sont connus
J'ai formulé une partie de mes lois en voulant que les conditions ne portent que sur les fonctions...
mais en soi les schéma relationnels des tables en entrée sont connus, car c'est une donnée statique,
propre au programme en question.


** Deux choix à faire
*** Adopte-t-on la définition join = select o x ?
Ou alors se restreint-on à une sorte de JOIN LEFT avec
la définition ensembliste?


*** Comment faire intervenir défragmentation et jointure?


* Prise de notes
** Doutes résolus
*** La transformation de requête de base en requête optimisée est-elle automatisée?
Non.
**** Discours actuel
Les transformations à appliquer sont laissées au choix du développeur en
fonction de ce qu'il veut optimiser spécifiquement pour son programme
**** Travail futur
Le développeur pourrait rentrer une liste de priorités de critères à optimiser
pour son programme, et en se basant sur cette liste, le choix
des lois à appliquer pourrait être automatisé, pour aboutir automatiquement
à la requête C2QL optimale.


*** Que vérifie le typage Idris?
Actuellement, le système de typage Idris sert à vérifier
que la composition faite aura un sens au moment de l'exécution
(i.e. elle sert à éviter certaines erreurs de programmation)
 

*** Quelles compilations manquent?
**** La transformation en application concrète exécutable
S'il avait eu le temps, Ronan l'aurait faite en JavaScript pour
le côté client et en Scala pour le côté serveur.


**** La compilation vers proVérif
La compilation vers le pi-calcul a été faite
et il a été expliqué comment compiler vers proVérif, mais
le compilateur vers proVérif n'a pas été codé.


*** L'implémentation actuelle permet-elle de mettre en place des mécanismes de sécurité?
Elle permet de les décrire (c'est le principal but de C2QL)
mais puisque la compilation vers une application concrète n'existe pas
encore, elle ne les mets pas vraiment en place.


*** L'implém actuelle donne-elle de l'assurance?
C'est le but de la transformation vers proVérif, qui n'est pas automatisée


*** Est-il possible d'accéder au livre d'Ullman?
Oui, Ronan me l'a passé.


*** ACHTUNG dans les lois, parfois les conditions d'application ne sont pas écrites
Comme c'est le cas dans la loi de permutation de selection et projection,
empruntée à Ullman. (équation 5 page 30)


*** La fragmentation et le rapatriment côté client appelés "cryptographie"?
Oui, car ce sont des techniques rendentant inintelligible...
**** pour la fragmentation,
l'association de données
**** pour le rapatriment côté client,
les données... vis à vis d'un attaquant qui intercepterait les comunications
sur les canaux de comunication


*** Est-il vraiment nécessaire de prouver correction d'un point de vue privacité alors que cc dès que nécessaire?
Justement, lorsque pour une loi algébrique il est question de
prouver la correction d'un point de vue privacité, il s'agit de savoir
si la gestion des fragments / du côté client envisagée
préserve bien les contraintes... MAIS CETTE GESTION EST IMPLICITE


*** L'implémentation en Scala a été abandonnée
Car elle utilisait largement les types dépendants, qui ne sont
pas une notions native au langage ni aisée d'utilisation
en Scala (en effet, pour faire apparaître des types dépendants, il
faudrait forcer le compilateur à calculer des types à la volée en utilisant
les implicits).
Idris plus adapté car manipule nativement les types dépendants


** Doutes / choses à voir
*** L'implémen actuelle permet-elle de définir une politique de sécurité?
Pas en C2QL, mais à priori oui, en Idris et proVérif
**** TODO regarder comment peuvent être définies les politiques de sécurité en Idris et proVérif


*** TODO Regarder les expérimentations de Ronan 
[[http://www.github.com/rcherrueau/C2QL/tree/master/experimentations][Dossier des expérimentations]]


*** Dans cryptDB
Est-ce que la partie "proxy" ne pourrait pas s'exécuter côté client
pour avoir un nuage confidentiel?




*** Est-ce que Ullman définit une sémantique précise?
Regarder le livre d'Ullman


*** Avoir plusieurs encodages/chiffrements et séparer les filtres
comme en CryptDB, pourrait-ce être une extension?


*** p.77 => toute fonction autre que décrypt commute avec defrag??
Non, ici le critère de validité se base sur l'hypothèse
qui la requête en question a été optenue avec la méthode
suggérée dans la thèse (d'abord version locale, puis 
protection, puis lois).

Il reste cependant à 
**** TODO *vérifier* que toutes les commutations faites avec le defrag peuvent être défaites de façon transparente.


*** p.78 => mais il peut y avoir un destructeur pour un fragment sans qu'il y en ai pour l'autre, non??
Non. Pas si la requête est sous forme canonique... et qu'il n'y a pas de defrags imbriqués!
**** TODO Est-ce qu'on veut vraiment se limiter au cas où il n'y a pas de defrags imbriqués?


*** p.78: il parle d'un \vee, qui n'apparaît nul part dans las formules...
**** TODO poser la question




** Remarques
*** Le rapatriment des données côté client n'étant pas explicite
les différent mécanismes de préservation de la confidentialité n'ont
pas tous le même statut... (cc n'a pas le même statut que frag ou crypt)
Initialement, ceci est dû au fait qu'on peut le déduire
de la position des constructeurs et des destructeurs


*** On fait apparaître les constructeurs de confidentialité à chaque requête...
pourtant ils doivent être les mêmes pour tout le programme,
pour toutes les requêtes.


** notes personelles
*** zero-knowledge proof
Permet de certifier l'intégrité d'un calcul sans transmission de données

*** notions de Saas, Paas et Iaas
Dans les exemple avec deux fragments, nécessité de louer deux Iaas et un Paas
*** ? filtres de Bloom ?
*** pi-calcul
En bref: lambda-calcul concurrent
*** chiffrement homomorphe
Le chiffrement de Gentry est un 
chiffrement homomorphe total, qui permet tout type d'opérations,
est couteux et demande à ce que le chiffrement soit raffraichit assez
fréquemment. Raffraîchissement long.
Mais il existe de nombreux chiffrements partiellement homomorphes:
**** permettant l'addition
**** permettant la multiplication
Comme ElGamal
**** permettant le test d'égalité
Les chiffrements déterministes en sont un cas particulier
(exemple: AES)
**** préservant l'ordre
*** Lors de la fragmentation verticale
Si dans un fragment une donnée est chiffrée,
la clé peut être stockée dans l'autre fragment.
*** Def loi algébriques
Transformation correcte d'une querry en une autre...
Ici, permutation correcte de deux fonctions
*** Regarder du côté de diVimercati pour la fragmentation verticale
*** Dans le pi-calcul, l'opérateur new
est une restriction car il limite la visibilité des cannaux.
En imposant à un canal d'être frais, nouveau, il 
restreint l'ensemble des processus pouvant s'en servir

*** Attention, la traduction en pi-calcul ne traduit que la communication avec le cloud
et non pas ce que se passe chez chaque acteur
=> au moment de traduire vers proVérif il faudra le prendre en compte,
pour les decrypt, par exemple


* Carnet de bord à partir du 12/06
** 12/06
Je vais plutôt commencer à démontrer les lois,
et je finirai d'énoncer les lois pour le fold après

Un des enjeux va être de trouver une façon efficace de régiger
les démonstrations, vu qu'il y en aura plus de 40...

*** Question que je me pose: Comment regrouper/ordoner les lois?
Le regroupement peut se faire par opérateur (proj, selections, ...)
ou par catégorie (qui relève des calculs locaux, qui relève du chiffrement,
qui relève de la comunication entre acteurs...).

Le regroupement par opérateurs me semble plus objectif, mais moins attrayant.

*** Projection et défragmentation
Pour pouvoir passer de droite à gauche dans cette loi, il est 
nécessaire de supposer que les schéma relationnels en entrée ont une intersection vide!

À nouveau deux possibilitées s'offraient à moi:
+ soit je passait d'une notion d'équivalence à une notion de transformation
pour pouvoir avoir dans un sens, une loi qui suppose moins d'hypothèses
+ soit j'impose une hypothèse sur les schémas relationnels en entrée.

À nouveau j'ai conclut que la deuxième possibilité était la meilleure
car de toute façons:
+ Dans le sens où on pourrait se passer de l'hypothèse sur les schémas,
elle est quand-même présente, dans le fait que l'expression écrite soit définie
+ On dispose des schémas relationnels des entrées

(Ce n'est qu'après avoir fait ce raisonnement que je me suis souvenu
que je l'avais déjà fait).

N'empêche,
j'avais pas vu la nécessité de préciser cette hypothèse dans cette loi-là,
donc je vais pouvoir *corriger la loi en question*.

**** Devrais-je informer Ronan, Fatima et Mario de la modif à appliquer à la loi 12? 
Je verrai ça cette après-midi avec Mario.


** 13/06
Aujourd'hui, il serait important d'alterner entre
+ Démonstrations
+ Lois pour le fold
+ Relecture
Je me propose moi-même des blocs de 40 minutes
pour les deux premières activités, et de 20 minutes
pour la troisième.

*** Pour avoir une trace de ce que j'ai fait aujourd'hui
Voir les commits sur le git

*** re-lecture des définitions jusqu'à Agrégation
*** Pour l'intéraction groupe/fold... les deux sens se comportent pareil, malgré ma première impression
Si des éléments sont les mêmes leurs immages par une fonction sont les mêmes également,
mais pour faire la déduction inverse il faut que la fonction en question soit injective.

À cause de ça, l'intéraction entre fold et group (dans le cas où l'attribut reduit
est un des attributs sur lesquels porte le regroupement) ne se comporte pas de la même
façon qu'on aille dans un sens où dans l'autre, car 
dans l'un des deux sens l'hypothèse "f injective" est nécessaire.
Et cette fois ce n'est pas une hypothèse qui soit cachée dans le fait
que les quantités soient définies au départ...

J'ai rien dit... Dans les deux cas on a besoin d'une fonction injective car sinon
dans l'un des deux sens on serait en train d'agrandir les groupes du regroupement,
et dans l'autre sens on serait en train de les réduire.
