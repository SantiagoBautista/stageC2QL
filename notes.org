* Grandes lignes
** Définir une notion de complétude pour les lois algébrique
*** Première idée: 
[[*Première idée de critère de complétude][Complétude formelle: exprimer toutes les requêtes équivalentes]]

Intuition: J'ai l'impression que pour que ce critère de
complétude puisse être sattisfait, il faudrait créer des nouvelles
lois identité, pour pouvoir faire apparaître au besoin toutes les différentes
fonctions dont peut être composée une requête C2QL


*** Deuxième approche:
Moins formellement, on peut garder la même approche que Ronan et vérifier si
+ Les catégories de lois qu'il propose comprennent toutes les transformations
qu'on peut vouloir faire
+ Chaque catégorie est complète


*** Troisième approche
Vu que toutes les lois algébriques de C2QL s'intéressent à la composition,
voir à la commutativité, de différentes fonctions,
une troisième approche serait de 
dresser un *tableau* pour toutes les composition de deux fonctions de C2QL.


** Établir la correction des lois algébriques
*** Correction sémantique
Pour la correction sémantique d'une loi algébrique on peut prendre
pour définition celle qui à priori est la définition d'Ullman (82) :
Deux fonctions sont sémantiquement équivalentes si elle coïncident
sur l'ensemble de toutes les relations, indépendament du schéma relationnel

Pour démontrer la correction sémantique, il me semble que la seule chose
qui peut s'avérer gênante est la présence de comportements *implicites* dans
les lois fournies. En effet, la loi (20) par exemple [page 66 de la thèse]
nécessite d'une synchronisation/séquentialisaiton des calculs effectués
sur chacun des deux fragments pour être juste.
Cette synchronisation est un effet de bord, qui n'apparâit pas 
dans l'écriture de la requête comme composition de fonctions
(parce que de fait, les fonctions du langage C2QL ne sont pas des fonctions
pures).

Il a été mentionné qu'une extension possible serait de rendre *explicite* 
dans C2QL la gestion des deux bases de données / clouds distinct(e)s...
Si cela est fait, l'information transmise d'une DB à l'autre serait
de ce fait rendue explicite (et donc en particulier la synchronisation
nécessaire pour la tranformation (20) serait explicite) et cela
résoudrait la gêne que j'ai exprimé précédemment.

*** Correction de l'équivalence de confidentialité
Le mantient de la confidencialité, lui aussi, repose grandement
sur des mécanismes potant sur
- le rapatriment des données côté client
- la nature des informations transmises à tel ou tel fragment de la base de données
Prouver que les transformations préservent la confidentialité pourrait donc
également être facilité par l'introduction explicite de la genstion
des diférents clouds et des comunications entre les différents agents.
Dans le travail déjà effectué, cette introduction a surement lieu lors de la traduction
en pi-calcul.


** Extensions possibles

*** Plus de deux fragements
Actuellement les fonctions de fragmentation/défragmentation
sont faites pour fragmenter/défragmenter en/depuis 2 segments.
Une idée pourrait être de généraliser ces fonctions pour
travailler avec un nombre quelconque de segments.


*** Plus d'un utilisateur
Pour le moment, le langage a été construit en considérant qu'il y a
un seul utilisateur du service à la fois, "Alice".
Faudrait-il étendre le langage pour gérer plusieurs utilisateurs qui
utilisent la ressource au même temps?


*** Autres propriétés de sécurité que Privacité
En ce moment, le langage permet au développeur
de réfléchir sur comment il va composer les
mécanismes de sécurité pour préserver la privacité/confidentialité
des données.
On pourrait introduire également dans le langage des mécanismes
permettant de préserver d'autres propriétés de sécurité,
telles que *l'intégrité*, par exemple.


*** Faire apparaître dans le langage la répartition entre plusieurs clouds
En ce moment, la gestion des différents clouds (nécessaire pour la
gestion correcte de la fragmentation) est faite implicitement,
et manuellement.
Des idées pourraient être soit de l'automatiser (en fonction des contraintes
de privacité, suggérer une répartition qui marche) soit de la rendre
explicite dans le langage.


*** Si ce n'ai déjà fait, généraliser avec group/fold au lieu de count
Dans la thèse, toutes les lois sont exprimées avec count
Un langage disposant des fonction group et fold étant plus expressif
qu'un langage ne disposant que de count,
je trouverai ça intéressant de, si ce n'est déjà fait,
intégrer complétement les fonctions group et fold au langage.


** Autres

*** Compilation vers proVérif
En ce moment, la transformation vers le pi-calcul
est codée, mais pas celle vers proVérif.
Coder la transformation vers proVérif
permettrait de vérifier automatiquement la correction
des programmes codés en C2QL


*** Modifications visant à simplifier les preuves
Si nécessaire, il est possible de modifier le langage
pour faciliter les preuves



* Choses à faire (dans l'immédiat)
** C2QL
*** S'intéresser à la complétude du système de lois algébriques
**** Faire la liste des lois algébriques
J'ai réuni dans un seul endroit toutes les lois, reformulées
[[file:lois/ensemble_lois.pdf][Ensemble des lois]]

***** DONE Demander à Ronan le code tex
Si je peux avoir le fichier .tex de la thèse ou de l'article,
cela m'éviterait de devoir taper de 0 toutes les loi

***** DONE Regrouper les lois apparaissant dans la thèse 
[[file:lois/ensemble_lois_these.pdf][Ensemble des lois apparaissant dans la thèse]]
Emplacements de référence des différentes lois dans la thèse: pages 30 et 63


***** DONE Regarder si elles contiennent les lois apparaissant dans l'article
Non.
+ Dans l'article les lois sont formulées en thermes de group et non de count
+ les lois de sélection sont plus rigoureuses (domaines <- selec sur plus
d'un attribut à la fois)
+ Il y a à la fois de la fragmentation verticale 
et de la fragmentation horizontale
***** DONE Choisir quel ensemble de lois garder initialement
****** DONE Se familiariser avec les macros LaTeX / en créer des propres
******* projections
\pi_{\delta} suffit
******* sélections
\sigma_p suffit
******* frag, defrag, crypt et decrypt
Je vais déclarer des opérateurs amsmath
******* group/fold
Je trouve plus pertinent de travailler avec les fonctions
group et fold, plus générales, que avec la fonction count, qui est
un cas particulier.

\mathrm{group}_{delta}
\mathrm{fold}_{f, z}
****** DONE Faut-il garder la fragmentation horizontale?
Pas nécessaire d'écrire toutes les lois, juste la mentionner
****** Garder les lois de projection de la thèse, pas de l'article
Les définitions avec les intersections sont plus claires et probablement
plus justes que les distinctions a/aBarre


**** Définir une notion de complétude du système de lois
***** DONE Première idée de critère de complétude
Vu que l'objectif de C2QL est d'aider le développeur
à composer les mécanismes de sécurité de sorte à optenir un système
sûr, efficace et nuagique, pour l'instant il me semble que la notion de complétude
qu'il serait le plus intéressant de vérifier est:

À partir d'une requête C2QL, l'ensemble des lois
permet-il d'exprimer toutes les requêtes
étant sémantiquement équivalantes à la requête initiale?

Si cette propriété de complétude était vérifiée, on serait sûrs de pouvoir
optenir la requête la mieux optimisée, quel que soit le critère d'optimisation.

***** DONE Deuxième approche du critère de complétude
[[*Deuxième approche:][Complétude informelle: ensmb des catégories, et catégories elles-mêmes]]

***** DONE Lire Ullman pour réfléchir à la pertinance des critères
Peut-être Ullman définit-il un autre critère de complétude pour
l'ensemble de ses lois? Peut-être définit-il ce critère-ci et le
prouve pour son ensemble de lois?

Non. Ullman ne se soucie pas de complétude.

***** DONE Troisième approche: Toutes les compositions 2 à 2
Le but de toutes les lois algébriques est de, par permutation,
permettre une optimisation de la requête exécutée.

On serait du coup sûrs d'avoir explorée complétement
cette approche si *pour toute paire de fonctions C2QL* on
a une loi décrivant la possibilité, les conditions et
le résultat d'une permutation entre elles.


**** Vérifier si le système de lois vérifie le critère de complétude
***** TODO Pour la première approche 
ça ne saurait tarder...
***** DONE Pour la deuxième approche
Il manque des lois pour le fold, une des lois pour crypt, etc...
***** TODO Pour la troisième approche
Faire le tableau des lois existantes actuellement


**** Compléter le système de lois
Ceci sera fait pour la troisième approche,
la première étant probablement impossible et la deuxième
étant contenue dans la troisième.

***** TODO Dresser et *compléter* le tableau de lois de commutation


*** Remplacer count par group/fold...
**** ... dans les lois
***** DONE Prendre les lois de group de l'article, plutôt que les lois de group
***** TODO ajouter des lois pour le fold
**** TODO dans l'implémentation actuelle de C2QL si ce n'est déjà fait

** ORGanisation
*** DONE Passer mes notes en ORG mode
Fait :-)
[[*Prise de notes][Prise de notes]]


*** DONE Créer un dépôt git
[[https://github.com/SantiagoBautista/stageC2QL.git][Dépôt git du stage]]



* Erreurs trouvées
** Composition de plusieurs projections
(p. 30 de la thèse) Projeter sur plusieurs sous-ensembles
en cascade revient à projeter sur l'intersection, et non sur l'union

Pour la sémantique qu'il donne à \pi_{a_1, ..., a_n},
voir exemple page 29 ou définition page 28

*** Contre-exemple 
Si on considère la relation r suivante
| a_1 | a_2 |
|-----+-----|
| a   |   1 |
| b   |   2 |
son image par $\pi_{a_2}$ est
| a_2 |
|-----|
|   1 |
|   2 |
dont l'image par $\pi_{a_1}$ est la table vide

Ainsi, l'image de r par
$\pi_{a_1} \circ \pi_{a_2}$ est la table vide.

Par contre, l'immage de r par
$\pi_{a_1, a_2}$
est la table r elle-même,
qui est différente de la table vide.

Ainsi donc, la loi (3) à la page 30 de la thèse est fausse.





** Chiffrement et sélection
Dans l'article, pour les lois (14) et (15),
la discussion ne devrait pas porter sur dom(p)\in\P(a)
mais sur dom(p) \cap a = \emptyset

*** Contre-exemple
On prend pour prédicat p 
p: a_1 + a_2 < 10

pour fonction de chiffrement s
s: n |-> n+50

et pour ensemble des attributs chiffrés a
a: {a_1}

Le domaine de p est alors {a_1, a_2}
qui n'est pas une partie de a.
On est donc dans les hypothèses mentionnées
dans l'article pour la loi (14)

On s'intéresse à la relation r
| a_1 | a_2 |
|-----+-----|
|  51 |   2 |

L'image de r par
$\sel_p \circ \decrypt{s}{a_1}$
est la relation
| a_1 | a_2 |
|-----+-----|
|   1 |   2 |

L'image de r par
$\decrypt{s}{a_1} \circ \sel_p$
est la relation vide.

Ainsi donc, la relation (14)
dans l'article est fausse.
(Car la condition donnée n'est pas assez restrictive)

Inversement, la loi (15), qui est là pour être appliquée
lorsque la loi (14) ne s'applique pas, est, dans l'article,
trop restrictive.



* Prise de notes
** Doutes résolus
*** La transformation de requête de base en requête optimisée est-elle automatisée?
Non.
**** Discours actuel
Les transformations à appliquer sont laissées au choix du développeur en
fonction de ce qu'il veut optimiser spécifiquement pour son programme
**** Travail futur
Le développeur pourrait rentrer une liste de priorités de critères à optimiser
pour son programme, et en se basant sur cette liste, le choix
des lois à appliquer pourrait être automatisé, pour aboutir automatiquement
à la requête C2QL optimale.


*** Que vérifie le typage Idris?
Actuellement, le système de typage Idris sert à vérifier
que la composition faite aura un sens au moment de l'exécution
(i.e. elle sert à éviter certaines erreurs de programmation)
 

*** Quelles compilations manquent?
**** La transformation en application concrète exécutable
S'il avait eu le temps, Ronan l'aurait faite en JavaScript pour
le côté client et en Scala pour le côté serveur.


**** La compilation vers proVérif
La compilation vers le pi-calcul a été faite
et il a été expliqué comment compiler vers proVérif, mais
le compilateur vers proVérif n'a pas été codé.


*** L'implémentation actuelle permet-elle de mettre en place des mécanismes de sécurité?
Elle permet de les décrire (c'est le principal but de C2QL)
mais puisque la compilation vers une application concrète n'existe pas
encore, elle ne les mets pas vraiment en place.


*** L'implém actuelle donne-elle de l'assurance?
C'est le but de la transformation vers proVérif, qui n'est pas automatisée


*** Est-il possible d'accéder au livre d'Ullman?
Oui, Ronan me l'a passé.


*** ACHTUNG dans les lois, parfois les conditions d'application ne sont pas écrites
Comme c'est le cas dans la loi de permutation de selection et projection,
empruntée à Ullman. (équation 5 page 30)


*** La fragmentation et le rapatriment côté client appelés "cryptographie"?
Oui, car ce sont des techniques rendentant inintelligible...
**** pour la fragmentation,
l'association de données
**** pour le rapatriment côté client,
les données... vis à vis d'un attaquant qui intercepterait les comunications
sur les canaux de comunication


*** Est-il vraiment nécessaire de prouver correction d'un point de vue privacité alors que cc dès que nécessaire?
Justement, lorsque pour une loi algébrique il est question de
prouver la correction d'un point de vue privacité, il s'agit de savoir
si la gestion des fragments / du côté client envisagée
préserve bien les contraintes... MAIS CETTE GESTION EST IMPLICITE


*** L'implémentation en Scala a été abandonnée
Car elle utilisait largement les types dépendants, qui ne sont
pas une notions native au langage ni aisée d'utilisation
en Scala (en effet, pour faire apparaître des types dépendants, il
faudrait forcer le compilateur à calculer des types à la volée en utilisant
les implicits).
Idris plus adapté car manipule nativement les types dépendants


** Doutes / choses à voir
*** L'implémen actuelle permet-elle de définir une politique de sécurité?
Pas en C2QL, mais à priori oui, en Idris et proVérif
**** TODO regarder comment peuvent être définies les politiques de sécurité en Idris et proVérif


*** TODO Regarder les expérimentations de Ronan 
github.com/rcherrueau/C2QL/tree/master/experimentations


*** Dans cryptDB
Est-ce que la partie "proxy" ne pourrait pas s'exécuter côté client
pour avoir un nuage confidentiel?




*** Est-ce que Ullman définit une sémantique précise?
Regarder le livre d'Ullman


*** Avoir plusieurs encodages/chiffrements et séparer les filtres
comme en CryptDB, pourrait-ce être une extension?


** Remarques
*** Le rapatriment des données côté client n'étant pas explicite
les différent mécanismes de préservation de la confidentialité n'ont
pas tous le même statut... (cc n'a pas le même statut que frag ou crypt)
Initialement, ceci est dû au fait qu'on peut le déduire
de la position des constructeurs et des destructeurs


*** On fait apparaître les constructeurs de confidentialité à chaque requête...
pourtant ils doivent être les mêmes pour tout le programme,
pour toutes les requêtes.


** notes personelles
*** zero-knowledge proof
Permet de certifier l'intégrité d'un calcul sans transmission de données

*** notions de Saas, Paas et Iaas
Dans les exemple avec deux fragments, nécessité de louer deux Iaas et un Paas
*** ? filtres de Bloom ?
*** pi-calcul
En bref: lambda-calcul concurrent
*** chiffrement homomorphe
Le chiffrement de Gentry est un 
chiffrement homomorphe total, qui permet tout type d'opérations,
est couteux et demande à ce que le chiffrement soit raffraichit assez
fréquemment. Raffraîchissement long.
Mais il existe de nombreux chiffrements partiellement homomorphes:
**** permettant l'addition
**** permettant la multiplication
Comme ElGamal
**** permettant le test d'égalité
Les chiffrements déterministes en sont un cas particulier
(exemple: AES)
**** préservant l'ordre
*** Lors de la fragmentation verticale
Si dans un fragment une donnée est chiffrée,
la clé peut être stockée dans l'autre fragment.
*** Def loi algébriques
Transformation correcte d'une querry en une autre...
Ici, permutation correcte de deux fonctions
*** Regarder du côté de diVimercati pour la fragmentation verticale
*** Dans le pi-calcul, l'opérateur new
est une restriction car il limite la visibilité des cannaux.
En imposant à un canal d'être frais, nouveau, il 
restreint l'ensemble des processus pouvant s'en servir


** notes à ranger
*** TODO p.77 => toute fonction autre que décrypt commute avec defrag??
Non, ici le critère de validité se base sur l'hypothèse
qui la requête en question a été optenue avec la méthode
suggérée dans la thèse (d'abord version locale, puis 
protection, puis lois).

Il reste cependant à *vérifier* que toutes les commutations faites avec
le defrag peuvent être défaites de façon transparente.

*** Chercher dans Supernova (Univ Rennes 1) article sur la complétude
Le plus proche que j'ai pu trouver est un article d'économie sur
la modélisation mathématique de, grosso modo, le pouvoir d'achat
des ménages...
[[file:completude_economie.pdf][Systèmes complets de fonctions de demande]]
