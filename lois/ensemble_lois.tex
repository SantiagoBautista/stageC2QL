\documentclass[french]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[a4paper]{geometry}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\newcommand{\uconcat}{\ensuremath{+\!\!\!+\,}}

\DeclareMathOperator{\proj}{\pi}
\DeclareMathOperator{\sel}{\sigma}
\DeclareMathOperator{\frag}{frag}
\DeclareMathOperator{\defrag}{defrag}
\DeclareMathOperator{\crypt}{crypt}
\DeclareMathOperator{\decrypt}{decrypt}
\DeclareMathOperator{\group}{group}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\dom}{dom}

\newcommand\typeT[1]{\text{\ttfamily #1}}
\newcommand{\decryptArgs}[2]{\decrypt_{#1 , \typeT{#2}}}
\newcommand{\cryptArgs}[2]{\crypt_{#1 , \typeT{#2}}}
\newcommand{\projDelta}{\proj_{\delta}}
\newcommand{\selP}{\sel_p}
\newcommand{\decryptCAlpha}{\decryptArgs{\alpha}{c}}
\newcommand{\cryptCAlpha}{\cryptArgs{\alpha}{c}}
\newcommand{\ch}{\typeT{c}}
\newcommand{\chp}{\typeT{c'}}
\newcommand{\groupDelta}{\group_{\delta}}
\newcommand{\fragDelta}{\frag_{\delta}}

\begin{document}
\section*{Lois déjà présentes dans la thèse et/ou l'article}
\subsection*{Lois locales}
\begin{align}
	\proj_{\delta_1}\circ \dots \circ \proj_{\delta_n} 
	&\equiv \proj_{\delta_1 \cap \dots \cap \delta_n} \\
	\sel_{p_1} \circ \dots \circ \sel_{p_n}
	&\equiv \sel_{p_1 \wedge \dots \wedge p_n} \\
	\projDelta \circ \selP
	& \equiv \selP \circ \projDelta
	& \text{si $\dom(p) \subset \delta$}
\end{align}
\subsection*{Lois identité}
\begin{align}
	\id & \equiv \defrag \circ \fragDelta \\
	\id & \equiv \decryptArgs{\alpha}{c} \circ \cryptArgs{\alpha}{c}
\end{align}

\subsection*{Lois de projection}
\begin{align}
\projDelta \circ \decryptArgs{\alpha}{c}
& \equiv \decryptArgs{\alpha}{c} \circ \projDelta
&\text{si $\alpha \in \delta$}\\
\projDelta \circ \decryptArgs{\alpha}{c}
& \equiv \projDelta
&\text{si $\alpha \notin \delta$} \\
\projDelta \circ \defrag
& \equiv \defrag \circ (\proj_{\delta \cap \delta'}, \proj_{\delta \setminus \delta'})
& \text{où $\delta'$ est le schéma relationnel du premier fragment}
\end{align}

\subsection*{Lois de sélection}
Lorsqu'une défragmentation est effectuée, on supposera que le schéma relationnel
du fragment de gauche s'appelle $\delta'$ .
\begin{align}
\selP \circ \decryptCAlpha 
& \equiv \decryptCAlpha \circ \selP
& \text{si $\dom(p) \cap \alpha = \emptyset$} \\
\selP \circ \decryptCAlpha 
& \equiv \decryptCAlpha \circ \sel_{\typeT{c} \Rightarrow p}
& \text{si $p$  est compatible avec $\typeT{c}$} \\
\selP \circ \defrag 
& \equiv \defrag \circ (\selP, \id)
& \text{si $dom(p) \subset \delta'$} \\
\selP \circ \defrag 
& \equiv \defrag \circ (\id, \selP)
& \text{si $dom(p) \subset \Delta \setminus \delta'$}
\end{align}
 
\subsection*{Lois d'agrégation}
Pour tout chiffrement $\ch$,
on appellera $\chp$
le chiffrement qui agit sur une liste en appliquant
$\ch$ à chacun des éléments de la liste.
Lorsqu'une défragmentation est effectuée, on supposera que le schéma relationnel
du fragment de gauche s'appelle $\delta'$ .
\begin{align}
\groupDelta \circ \decryptCAlpha
& \equiv \decryptArgs{\alpha}{\chp} \circ \groupDelta
& \text{Si $\alpha \notin \delta$} \\
\groupDelta \circ \decryptCAlpha
& \equiv \decryptCAlpha \circ \groupDelta
& \text{Si $\ch$ est compatible avec l'égalité} \\
\groupDelta \circ \defrag 
& \equiv \defrag \circ (\groupDelta, \group_{\{\id\}})
& \text{Si $\delta \subset \delta'$} \\
\groupDelta \circ \defrag 
& \equiv \defrag \circ (\group_{\{\id\}}, \groupDelta)
& \text{Si $\delta \cap \delta' = \emptyset$} 
\end{align}

\subsection*{Lois de composition des protections}
Lorsqu'une défragmentation est effectuée, on supposera que le schéma relationnel
du fragment de gauche s'appelle $\delta'$ .
\begin{align}
\id \circ \operatorname{f}
\equiv \operatorname{f} \circ \id
\equiv \operatorname{f} \\
\fragDelta \circ \decryptCAlpha
& \equiv (\decryptCAlpha, \id) \circ \fragDelta
& \text{si $\alpha \in \delta'$} \\
\fragDelta \circ \decryptCAlpha
& \equiv (\id, \decryptCAlpha) \circ \fragDelta
& \text{si $\alpha \notin \delta'$} \\
\decryptCAlpha \circ \defrag 
& \equiv \defrag \circ (\decryptCAlpha, \id)
& \text{si $\alpha \in \delta'$} \\
\decryptCAlpha \circ \defrag 
& \equiv \defrag \circ (\id, \decryptCAlpha)
& \text{si $\alpha \notin \delta'$} \\
\fragDelta \circ \cryptCAlpha
& \equiv (\cryptCAlpha, \id) \circ\fragDelta 
& \text{si $\alpha \in \delta'$} \\
\fragDelta \circ \cryptCAlpha
& \equiv (\id, \cryptCAlpha) \circ\fragDelta 
& \text{si $\alpha \notin \delta'$}
\end{align}

\section*{Lois que je propose de rajouter}
\subsection*{Commutation de $\defrag$ et $\crypt$}
Lorsqu'une défragmentation est effectuée, on supposera que le schéma relationnel
du fragment de gauche s'appelle $\delta'$ .
\begin{align}
\cryptCAlpha \circ \defrag 
& \equiv \defrag \circ (\cryptCAlpha, \id)
& \text{si $\alpha \in \delta'$} \\
\cryptCAlpha \circ \defrag 
& \equiv \defrag \circ (\id, \cryptCAlpha)
& \text{si $\alpha \notin \delta'$} 
\end{align}

\subsection*{Lois évidentes}
\begin{align}
\cryptCAlpha \circ \cryptArgs{\beta}{s}
& \equiv \cryptArgs{\beta}{s} \circ \cryptCAlpha
& \text{si $\alpha \neq \beta$}
\end{align}
A priori, chiffrer une donnée déjà chiffrée semble une mauvaise idée de tous points de vue.

\begin{align}
\decryptCAlpha \circ \decryptArgs{\beta}{s}
& \equiv \decryptArgs{\beta}{s} \circ \decryptCAlpha
& \text{si $\alpha \neq \beta$}
\end{align}
A priori, déchiffrer une donnée déjà déchiffrée semble une mauvaise idée de tous points de vue.

\subsection*{Lois d'agrégation}
\begin{align}
\groupDelta \circ \proj_{\delta'}
& \equiv \proj_{\delta'} \circ \groupDelta
& \text{si $\delta \subset \delta'$} \\
\groupDelta \circ \selP 
& \equiv \selP \circ \groupDelta
& \text{si $\dom(p) \subset \delta$} \\
\text{$\group$ ne commute pas avec lui-même}
\end{align}

\subsection*{Lois de jonction}
\subsubsection*{Caractère statique}
La transformation

\begin{align}
\defrag \circ (\id, \Join)
& \rightarrow &\Join (\defrag, \id)
\end{align}
 
est toujours valable;
mais la transformation inverse ne l'est pas toujours.

\subsubsection*{Caractère dynamique}
Si on a trois tables $r_1$, $r_2$ et $r_3$,
que $r_2$ et $r_3$ sont joignables
et que $r_1$ est unifiable avec $r_2 \Join r_3$
alors:

\begin{align}
\defrag(r_1, r_2 \Join r_3) = & \defrag(r_1, r_2) \Join r_3
\end{align}


\subsection*{Lois du fold}
A FAIRE

\end{document}
