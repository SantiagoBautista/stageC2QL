\documentclass[french]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[a4paper]{geometry}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{latexsym} %maybe needed for \Join %nope, it doesn't seem so

\newcommand{\uconcat}{\ensuremath{+\!\!\!+\,}}

\DeclareMathOperator{\proj}{\pi}
\DeclareMathOperator{\sel}{\sigma}
\DeclareMathOperator{\frag}{frag}
\DeclareMathOperator{\defrag}{defrag}
\DeclareMathOperator{\crypt}{crypt}
\DeclareMathOperator{\decrypt}{decrypt}
\DeclareMathOperator{\group}{group}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\ens}{E}
\DeclareMathOperator{\R}{R}
\DeclareMathOperator{\Sc}{S}
\DeclareMathOperator{\s}{sch}
\DeclareMathOperator{\ls}{L}
\DeclareMathOperator{\ru}{Ru}
\DeclareMathOperator{\uni}{Unif}
\DeclareMathOperator{\cor}{cor}
\DeclareMathOperator{\rj}{Rj}
\DeclareMathOperator{\enc}{Enc}
\DeclareMathOperator{\dec}{Dec}
\DeclareMathOperator{\ids}{IDs}
\DeclareMathOperator{\lgr}{lg}
\DeclareMathOperator{\redu}{red}
\DeclareMathOperator{\head}{hd}
\DeclareMathOperator{\tail}{tl}
\DeclareMathOperator{\hfrag}{hfrag}
\DeclareMathOperator{\hdefrag}{hdefrag}

\newcommand\typeT[1]{\text{\ttfamily #1}}
\newcommand{\decryptArgs}[2]{\decrypt_{#1 , \typeT{#2}}}
\newcommand{\cryptArgs}[2]{\crypt_{#1 , \typeT{#2}}}
\newcommand{\projDelta}{\proj_{\delta}}
\newcommand{\selP}{\sel_p}
\newcommand{\decryptCAlpha}{\decryptArgs{\alpha}{c}}
\newcommand{\cryptCAlpha}{\cryptArgs{\alpha}{c}}
\newcommand{\ch}{\typeT{c}}
\newcommand{\chp}{\typeT{c'}}
\newcommand{\groupDelta}{\group_{\delta}}
\newcommand{\fragDelta}{\frag_{\delta}}
\newcommand{\val}{\mathcal{V}}
\newcommand{\cy}[1]{\typeT{c}(#1)}
\newcommand{\dc}[1]{\typeT{c}^{-1}(#1)}
\newcommand{\cip}{\cup \{id\}}
\newcommand{\fold}[3]{\operatorname{fold}_{#1, #2, #3}}
\newcommand{\foldAlphafz}{\fold{\alpha}{f}{z}}

\newtheorem{defi}{Définition}

\begin{document}
Le but de ce document est de donner une définition
formelle des fonctions dont est composé le langage C2QL.

\subsection*{Préambule}
\begin{defi}
	Ici, pour simplifier, on appelle chaîne de caractères
	tout mot sur l'alphabet 
	$$
	\Sigma = \{a, \dots, z\} \cup \{A, \dots, Z \} \cup \{0, \dots,  9 \}
 	$$
\end{defi}

\begin{defi}
	On appelle \emph{nom d'attribut} toute chaîne de caractères.
\end{defi}	

\begin{defi}
	On appelle \emph{schéma relationnel} tout ensemble
	de noms d'attributs.
\end{defi}

\subsection*{Définitions générales}
Soit $\val$ un ensemble, appelé ensemble des valeurs.

\begin{defi}
	On appelle \emph{relation} de schéma relationnel $\Delta$
	un ensemble de fonctions de $\Delta \cup \{ id \}$ dans $\val$.
	
	Chacun des éléments de la relation (chacune de ces fonctions)
	est appelé(e) \emph{ligne}.
	
	Pour chaque ligne $l$ de la relation et chaque $\alpha$ de $\Delta$,
	$l(\alpha)$ est appelé \emph{attribut} de \emph{nom} $\alpha$ pour la ligne $l$.
	
	L'image de $id$ est appelée \emph{identifiant de la ligne}, et elle est, au sein de chaque
	relation, unique pour chaque ligne.
\end{defi}

\begin{defi}
	On appelle $\Sc$ l'ensemble des schémas relationnels possibles.
	Autrement dit, on pose  $\Sc = \mathcal{P}\left( \Sigma^* \right)$.
	
	On appelle $\R$ l'ensemble des relations possibles,
	
	et on introduit la fonction $\s$ de $\R$ dans
	$\Sc$
	qui à une relation associe son schéma relationnel.
\end{defi}

\subsection*{Projections et sélections}
\begin{defi}
	Pour tout ensemble $\delta$ de noms d'attributs,
	on appelle \emph{projection sur les attributs $\delta$}
	la fonction suivante:
	$$
	\begin{array}{llcl}
	\projDelta:	& \R 	& \rightarrow 	& \R \\
				& r		& \mapsto		& 
					\{{l|}_{(\delta\cap \s(r)) \cup \{id\}} / l \in r \}
	\end{array}
	$$
\end{defi}

\begin{defi}
	On appelle $\ls$ l'ensemble de toutes les lignes possibles.
	
	On appelle \emph{prédicat} toute fonction
	de $\ls$ dans $\{true, false\}$.
	
	On appelle \emph{domaine} d'un prédicat $p$ le plus petit
	ensemble $D$ tel que:
	$$
	\forall (l, l') \in \ls^2, (l|_D = l'|_D \Rightarrow  p(l) = p(l')) 
	$$
	et on le note $\dom(p)$.
\end{defi}

\begin{defi}
	On appelle \emph{sélection de prédicat $p$}, pour tout prédicat $p$, la fonction:
	$$
	\begin{array}{llcl}
	\selP: 	& \R 	& \rightarrow 	& \R \\
			& r		& \mapsto		& r \cap p^{-1}(\{true\})
	\end{array}
	$$
\end{defi}

\subsection*{Jointure naturelle}
\begin{defi}
	On dit qu'\emph{une paire de relations} $(r,r')$ 
	est \emph{joignable} si on a:
	$$
	\begin{array}{lllr}
	\forall l \in r &
	\exists l' \in r' &
	\forall \alpha \in \s(r) \cap \s(r'), &
	l(\alpha) = l'(\alpha)
	\end{array}
	$$
	
	Si $(r,r')$ est une paire de relations joignables,
	et que $l$ est une ligne de $l$,
	on appelle \emph{correspondants de $l$ dans $r'$}
	l'ensemble des lignes $l'$ de la propriété précédente.
	On note $\cor_{r, r'}(l)$ l'ensemble de ces lignes-là.
\end{defi}

\begin{defi}
	Si $l$ et $l'$ sont deux lignes correspondantes,
	on appelle \emph{concaténation de $l$ et de $l'$},
	notée $l.l'$ la fonction de $\s(l) \cup \s(l') \cup \{id\}$
	définie par:
	$$
	\left\lbrace
	\begin{array}{ll}
	l.l'(\alpha)  = l(\alpha) & \text{si $\alpha \in \s(r) \setminus \s(r')$} \\
	l.l'(\alpha)  = l'(\alpha) & \text{si $\alpha \in \s(r') \setminus \s(r)$} \\
	l.l'(\alpha)  = l(\alpha) = l'(\alpha) & \text{si $\alpha \in \s(r) \cap \s(r')$} \\
	l.l'(id)  = l(id).l'(id) &  \\
	\end{array}
	\right.
	$$
	où $l(id).l'(id)$ est compris comme la concaténation de listes
	(les valeurs qui ne sont pas des listes sont assimilées
	à des listes avec un seul élément).
\end{defi}

\begin{defi}
	Pour $r$ et $r'$ deux relations joignables,
	on appelle \emph{jointure naturelle}
	de $r$ et $r'$ la table
	$$
	r \Join r' = \{l.l' / l \in r, l' \in \cor_{r, r'}(l) \}
	$$
	
	On utilisera aussi la notation préfixe.
	En effet, si on appelle $\rj$ l'ensemble
	des paires de relations joignables,
	on vient de définir la fonction
	$$
	\begin{array}{llcl}
	\Join : & \rj & \rightarrow & \R \\
			& (r, r') & \mapsto & r \Join r'
	\end{array}
	$$
\end{defi}

\subsection*{Fragmentation et défragmentation}
La défragmentation est un cas particulier de jointure naturelle,
le seul attribut en commun pour les deux tables est l'identifiant des lignes.

\begin{defi}
	Deux relations $r$ et $r'$ sont dites \emph{unifiables}
	si:
	$$
	\left\lbrace
	\begin{array}{l}
	\{l(id) / l \in r \} = \{l(id) / l \in r' \} \\
	\s(r) \cap \s(r') = \emptyset
	\end{array}
	\right.
	$$
	On remarquera que deux relations unifiables sont également joignables.
	
	On note $\ru$ l'ensemble des paires de relations unifiables,
	qui est donc un sous-ensemble de $\rj$, qui lui même
	est un sous-ensemble de $\R^2$.
\end{defi}

\begin{defi}
	Pour tout ensemble de noms d'attributs $\delta$
	on appelle \emph{fragmentation de fragment gauche $\delta$}
	l'application suivante:
	$$
	\begin{array}{llcl}
	\fragDelta 	& \R & \rightarrow & \ru \\
				& r  & \mapsto & (\{l|_{(\s(r)\cap \delta) \cup \{id\}}/ l \in r \}, 
						\{ l_{(\s(r) \setminus \delta)\cup \{id\}} / l \in r \})
	\end{array}
	$$
\end{defi}

\begin{defi}
	On appelle \emph{défragmentation} la
	restriction de la jointure naturelle à $\ru$.
	$$
	\begin{array}{llcl}
	\defrag:	& \ru & \rightarrow & \R \\
	& (r, r')  	& \mapsto & r \Join r'
	\end{array}
	$$
\end{defi}

\subsection*{Chiffrement et déchiffrement}
Vu que pour l'instant on s'intéresse uniquement aux contenus des 
tables pour démontrer la correction sémantique des lois
de composition, on ne parlera pas pour l'instant
des éventuelles clefs de chiffrement et déchiffrement.

\begin{defi}
	On appelle \emph{chiffrement} tout couple $\typeT{c}$ de fonctions $(\enc, \dec)$
	de $\val$ dans $\val$
	vérifiant
	$\displaystyle \dec \circ \enc = \id$.
	
	Pour toute valeur $v$ de $\val$
	on note $\cy{v} = \enc(v)$
	et $\dc{v} = \dec(v)$
\end{defi}

\begin{defi}
	Pour une ligne $l$ définie sur $\Delta$, pour $\alpha$ un attribut,
	et pour $\typeT{c}$ un chiffrement,
	on appelle \emph{version de $l$ chiffrée pour $\alpha$ avec le chiffrement
		$\typeT{c}$}
	la ligne notée $\cy{l}_\alpha$ définie par:
	$$
	\left\lbrace
	\begin{array}{lll}
	\forall \beta \in \Delta \setminus \{\alpha\} & \cy{l}_\alpha(\beta) = l(\beta) & \\
	& \cy{l}_\alpha(\alpha) = \cy{l(\alpha)} & \text{si $\alpha \in \Delta$}
	\end{array}
	\right.
	$$
	
	De même, on définit la \emph{version de $l$ déchiffrée pour $\alpha$ avec le chiffrement
		$\typeT{c}$}, notée $\dc{l}_\alpha$, par:
	$$
	\left\lbrace
	\begin{array}{lll}
	\forall \beta \in \Delta \setminus \{\alpha\} & \dc{l}_\alpha(\beta) = l(\beta) & \\
	& \dc{l}_\alpha(\alpha) = \dc{l(\alpha)} & \text{si $\alpha \in \Delta$}
	\end{array}
	\right.
	$$
\end{defi}

\begin{defi}
	Pour $\alpha$ un nom d'attribut
	et \typeT{c} un chiffrement,
	on appelle \emph{fonction de chiffrement de $\alpha$ par \typeT{c}}
	la fonction
	$$
	\begin{array}{llcl}
	\cryptCAlpha : & \R & \rightarrow & \R \\
		&	r	&	\mapsto & \{ \cy{l}_\alpha / l \in r \}
	\end{array}
	$$
	
	De même, on appelle \emph{fonction de déchiffrement de $\alpha$ par \typeT{c}}
	la fonction
	$$
	\begin{array}{llcl}
	\decryptCAlpha : & \R & \rightarrow & \R \\
	&	r	&	\mapsto & \{ \dc{l}_\alpha / l \in r \}
	\end{array}
	$$
\end{defi}

\subsection*{Agrégation}

\begin{defi}
	Pour $\delta$ un ensemble de noms d'attributs,
	on appelle \emph{nom de groupe pour $\delta$}
	toute application $n$ définie de $\delta \cup \{id\}$
	dans $\val$.
	
	On remarque que tout nom de groupe est une ligne.
	
	$\delta$ est appelé \emph{domaine} du nom de groupe $n$,
	et noté $\dom(n)$.
	
	De plus, pour $r$ une relation, on définit
	\emph{l'ensemble des noms de groupe de $r$ pour $\delta$}:
	$$
	r_\delta = \{l|_\delta / l \in r \}
	$$
\end{defi}

\begin{defi}
	Pour $r$ une relation et $n$ un groupe, on appelle
	\emph{groupe de $r$ pour le nom $n$} l'ensemble
	des éléments de $r$ coïncidant avec $n$ 
	sur $(\s(r)\cap\dom(n))\cup\{id\}$. On le note $r_n$.
	
	Autrement dit:
	$$
	r_n = \{l \in r / l|_{(\s(r)\cap\dom(n))\cup\{id\}}  = n|_{(\s(r)\cap\dom(n))\cup\{id\}} \}
	$$
	
	De plus, on appelle \emph{identifiants du groupe $r_n$} l'ensemble
	des identifiants des lignes du groupe. On note $\ids(r_n)$ cet ensemble.
	
	Autrement dit:
	$$
	\ids(r_n) = \{ l(id) / l \in r_n \}
	$$
\end{defi}

\begin{defi}
	Pour $r$ une relation, $n$ un nom de groupe,
	et $\alpha$ un attribut de
	$(\s(r) \setminus \dom(r)) \cup \{id\}$,
	on appelle \emph{valeurs du groupe $r_n$ pour
		l'attribut $\alpha$}
	la fonction
	$$
	\begin{array}{llcl}
	r_n(\alpha) : & \ids(r_n) & \rightarrow & \val \\
			& l(id) & \mapsto & l(\alpha)
	\end{array}
	$$
\end{defi}

\begin{defi}
	Pour $r$ une relation, et $n$ un nom de groupe,
	on appelle \emph{ligne de groupe de $r$ pour $n$}
	la ligne notée $\lgr_{r,n}$ définie sur $\s(r) \cip$ par:
	$$
	\left\lbrace
	\begin{array}{ll}
	\lgr_{r, n}(\alpha) = n(\alpha) & \text{si $\alpha \in \s(r) \cap \dom(n)$} \\
	\lgr_{r, n}(\alpha) = r_n(\alpha) & \text{si $\alpha \in (\s(r) \cip) \setminus \dom(n)$}
	\end{array}
	\right.
	$$ 
\end{defi}

\begin{defi}
	Pour $\delta$ un ensemble de noms d'attributs,
	on appelle \emph{fonction d'agrégation pour les attributs $\delta$}
	la fonction suivante:
	$$
	\begin{array}{llcl}
	\groupDelta: & \R & \rightarrow &  \R \\
			& r & \mapsto & \{ \lgr_{r,n} / n \in r_\delta \}
	\end{array}
	$$
\end{defi}

\subsection*{Réduction}
La plupart du temps, les agrégations sont faites pour pouvoir faire une
réduction ensuite.

On suppose que les identifiants des lignes peuvent être totalement ordonnés
et donc que les fonctions définies sur des ensembles d'identifiants peuvent
être vues comme des listes.

Pour toute liste $l$ on notera $\head(l)$ le premier élément de la liste,
et $\tail(l)$ le reste de la liste. \\

Dans les définitions qui suivent, $f$ est une fonction de $\val^2$ dans $\val$
et $z$ est un élément de $\val$.

\begin{defi}
	On appelle
	\emph{réduction d'une liste $t$ par la fonction $f$ avec l'élément neutre $z$}
	la valeur $\redu_{f, z}(t)$ définie par induction sur la liste par:
	$$
	\left\lbrace
	\begin{array}{l}
	\redu_{f,z}(\emptyset) = z \\
	\redu_{f,z}(t) = \redu_{f , f(z, hd(t))}(\tail(t))
	\end{array}
	\right.
	$$
	
	Si une valeur $v$ de $\val$ n'est pas une liste,
	on la considère alors comme une liste à un seul
	élément et on pose donc $\redu_{f,z}(v) = f(z,v)$.
\end{defi}

\begin{defi}
	Pour $l$ une ligne définie sur $\delta$,
	et $\alpha$ un nom d'attribut,
	on appelle
	\emph{réduction de l'attribut $\alpha$ dans la ligne $l$ 
		par la fonction $f$ avec l'élément neutre $z$}
	la ligne $\redu_{\alpha, f, z, l}$ définie sur $\delta$ par:
	$$
	\left\lbrace
	\begin{array}{ll}
	\redu_{\alpha, f, z, l}(\alpha) = \redu_{f,z}(l(\alpha)) & \\
	\redu_{\alpha, f, z, l}(\beta) = l(\beta) & \text{si $\beta \neq \alpha$}
	\end{array}
	\right.
	$$
\end{defi}

\begin{defi}
	On appelle \emph{fonction de réduction de l'attribut $\alpha$
		par la fonction $f$ avec l'élément neutre $z$} la fonction suivante:
	$$
	\left\lbrace
	\begin{array}{llcl}
	\foldAlphafz : & \R & \rightarrow & \R \\
				& r 	& \mapsto & \{ \redu_{\alpha, f, z, l} / l\in r \}
	\end{array}
	\right.
	$$
\end{defi}

\subsection*{Opérations ensemblistes: union, différence, fragmentation horizontale}
\begin{defi}
	On appelle \emph{union} ou \emph{défragmentation horizontale}
	de deux tables $r$ et $r'$ ayant le même schéma relationnel
	la table $r \cup r'$, aussi notée $\hdefrag(r, r')$.
\end{defi}

\begin{defi}
	On appelle \emph{différence ensembliste}
	de deux tables $r$ et $r'$ ayant le même schéma relationnel
	la table $r \setminus r'$.
\end{defi}

\begin{defi}
	Pour $p$ un prédicat, on appelle \emph{fragmentation horizontale 
		de critère $p$}
	la fonction
	$$
	\begin{array}{llcl}
	\hfrag : & \R \rightarrow & \R^2 \\
			& r & \mapsto & (\{l \in r / p(l)\} , \{l \in r, \neg p(l)\})
	\end{array}
	$$
\end{defi}

\end{document}