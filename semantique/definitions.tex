\documentclass[french]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[a4paper]{geometry}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{latexsym} %maybe needed for \Join

\newcommand{\uconcat}{\ensuremath{+\!\!\!+\,}}

\DeclareMathOperator{\proj}{\pi}
\DeclareMathOperator{\sel}{\sigma}
\DeclareMathOperator{\frag}{frag}
\DeclareMathOperator{\defrag}{defrag}
\DeclareMathOperator{\crypt}{crypt}
\DeclareMathOperator{\decrypt}{decrypt}
\DeclareMathOperator{\group}{group}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\ens}{E}
\DeclareMathOperator{\R}{R}
\DeclareMathOperator{\Sc}{S}
\DeclareMathOperator{\s}{sch}
\DeclareMathOperator{\ls}{L}
\DeclareMathOperator{\ru}{Ru}
\DeclareMathOperator{\uni}{Unif}
\DeclareMathOperator{\cor}{cor}
\DeclareMathOperator{\rj}{Rj}
\DeclareMathOperator{\enc}{Enc}
\DeclareMathOperator{\dec}{Dec}

\newcommand\typeT[1]{\text{\ttfamily #1}}
\newcommand{\decryptArgs}[2]{\decrypt_{#1 , \typeT{#2}}}
\newcommand{\cryptArgs}[2]{\crypt_{#1 , \typeT{#2}}}
\newcommand{\projDelta}{\proj_{\delta}}
\newcommand{\selP}{\sel_p}
\newcommand{\decryptCAlpha}{\decryptArgs{\alpha}{c}}
\newcommand{\cryptCAlpha}{\cryptArgs{\alpha}{c}}
\newcommand{\ch}{\typeT{c}}
\newcommand{\chp}{\typeT{c'}}
\newcommand{\groupDelta}{\group_{\delta}}
\newcommand{\fragDelta}{\frag_{\delta}}
\newcommand{\val}{\mathcal{V}}
\newcommand{\cy}[1]{\typeT{c}(#1)}
\newcommand{\dc}[1]{\typeT{c}^{-1}(#1)}

\newtheorem{defi}{Définition}

\begin{document}
Le but de ce document est de donner une définition
formelle des fonctions dont est composé le langage C2QL.

\subsection*{Définitions générales}
Soit $\val$ un ensemble, appelé ensemble des valeurs.
\begin{defi}
	Ici, pour simplifier, on appelle chaîne de caractères
	tout mot sur l'alphabet 
	$$
	\Sigma = \{a, \dots, z\} \cup \{A, \dots, Z \} \cup \{0, \dots,  9 \}
 	$$
\end{defi}

\begin{defi}
	On appelle \emph{nom d'attribut} toute chaîne de caractères.
\end{defi}	

\begin{defi}
	On appelle \emph{schéma relationnel} tout ensemble
	de noms d'attributs.
\end{defi}

\begin{defi}
	On appelle \emph{relation} de schéma relationnel $\Delta$
	un ensemble de fonctions de $\Delta \cup \{ id \}$ dans $\val$.
	
	Chacune de ces fonctions (chacun des éléments de la relation)
	est appelé(e) \emph{ligne}.
	
	Pour chaque ligne $l$ de la relation et chaque $\alpha$ de $\Delta$,
	$l(\alpha)$ est appelé \emph{attribut} de \emph{nom} $\alpha$ pour la ligne $l$.
	
	L'image de $id$ est appelé \emph{identifiant de la ligne}, et il est, au sein de chaque
	relation, unique pour chaque ligne.
\end{defi}

\begin{defi}
	On appelle $\Sc$ l'ensemble des schémas relationnels possibles.
	Autrement dit, on pose  $\Sc = \mathcal{P}\left( \Sigma^* \right)$.
	
	On appelle $\R$ l'ensemble des relations possibles,
	
	et on introduit la fonction $\s$ de $\R$ dans
	$\Sc$
	qui à une relation associe son schéma relationnel.
\end{defi}

\subsection*{Projections et sélections}
\begin{defi}
	Pour tout ensemble $\delta$ de noms d'attributs,
	on appelle \emph{projection sur les attributs $\delta$}
	la fonction suivante:
	$$
	\begin{array}{llcl}
	\projDelta:	& \R 	& \rightarrow 	& \R \\
				& r		& \mapsto		& 
					\{{l|}_{(\delta\cap \s(r)) \cup \{id\}} / l \in r \}
	\end{array}
	$$
\end{defi}

\begin{defi}
	On appelle $\ls$ l'ensemble de toutes les lignes possibles.
	
	On appelle \emph{prédicat} toute fonction
	de $\ls$ dans $\{true, false\}$.
	
	On appelle \emph{domaine} d'un prédicat $p$ le plus petit
	ensemble $D$ tel que:
	$$
	\forall (l, l') \in \ls^2, (l|_D = l'|_D \Rightarrow  p(l) = p(l')) 
	$$
	et on le note $\dom(p)$.
\end{defi}

\begin{defi}
	On appelle \emph{sélection de prédicat $p$}, pour tout prédicat $p$, la fonction:
	$$
	\begin{array}{llcl}
	\selP: 	& \R 	& \rightarrow 	& \R \\
			& r		& \mapsto		& r \cap p^{-1}(\{true\})
	\end{array}
	$$
\end{defi}

\subsection*{Jointure naturelle}
\begin{defi}
	On dit que \emph{deux relations} $r$ et $r'$
	sont \emph{joignables} si on a:
	$$
	\begin{array}{lllr}
	\forall l \in r &
	\exists! l' \in r' &
	\forall \alpha \in \s(r) \cap \s(r'), &
	l(\alpha) = l'(\alpha)
	\end{array}
	$$
	
	Si $r$ et $r'$ sont deux relations joignables
	et $l$ est une ligne de $r$,
	on appelle \emph{correspondant de $l$ dans
	$r'$} la ligne $l'$ de la propriété précédente
	(unique par définition).
	On note cette ligne $\cor_{r, r'}(l)$.
	
	On dit alors que $l$ et $l'$ sont
	\emph{deux lignes correspondantes}.
\end{defi}

\begin{defi}
	Si $l$ et $l'$ sont deux lignes correspondantes,
	on appelle \emph{concaténation de $l$ et de $l'$},
	notée $l.l'$ la fonction de $\s(l) \cup \s(l') \cup \{id\}$
	définie par:
	$$
	\left\lbrace
	\begin{array}{ll}
	l.l'(\alpha)  = l(\alpha) & \text{si $\alpha \in \s(r) \setminus \s(r')$} \\
	l.l'(\alpha)  = l'(\alpha) & \text{si $\alpha \in \s(r') \setminus \s(r)$} \\
	l.l'(\alpha)  = l(\alpha) = l'(\alpha) & \text{si $\alpha \in \s(r) \cap \s(r')$} \\
	l.l'(id)  = l(id) &  \\
	\end{array}
	\right.
	$$
\end{defi}

\begin{defi}
	Pour $r$ et $r'$ deux relations joignables,
	on appelle \emph{jointure naturelle}
	de $r$ et $r'$ la table
	$$
	r \Join r' = \{l.\cor_{r,r'}(l) / l \in r \}
	$$
	
	On utilisera aussi la notation préfixe.
	En effet, si on appelle $\rj$ l'ensemble
	des paires de relations unifiables,
	on vient de définir la fonction
	$$
	\begin{array}{llcl}
	\Join : & \rj & \rightarrow & \R \\
			& (r, r') & \mapsto & r \Join r'
	\end{array}
	$$
\end{defi}

\subsection*{Fragmentation et défragmentation}
La défragmentation est un cas particulier de jointure naturelle,
le seul attribut en commun pour les deux tables est l'identifiant des lignes.

\begin{defi}
	Deux relations $r$ et $r'$ sont dites \emph{unifiables}
	si:
	$$
	\left\lbrace
	\begin{array}{l}
	\{l(id) / l \in r \} = \{l(id) / l \in r' \} \\
	\s(r) \cap \s(r') = \emptyset
	\end{array}
	\right.
	$$
	On remarquera que deux relations unifiables sont également joignables.
	
	On note $\ru$ l'ensemble des paires de relations unifiables,
	qui est donc un sous-ensemble de $\rj$, qui lui même
	est un sous-ensemble de $\R^2$.
\end{defi}

\begin{defi}
	Pour tout ensemble de noms d'attributs $\delta$
	on appelle \emph{fragmentation de fragment gauche $\delta$}
	l'application suivante:
	$$
	\begin{array}{llcl}
	\fragDelta 	& \R & \rightarrow & \ru \\
				& r  & \mapsto & (\{l|_{(\s(r)\cap \delta) \cup \{id\}}/ l \in r \}, 
						\{ l_{(\s(r) \setminus \delta)\cup \{id\}} / l \in r \})
	\end{array}
	$$
\end{defi}

\begin{defi}
	On appelle \emph{défragmentation} la
	restriction de la jointure naturelle à $\ru$.
	$$
	\begin{array}{llcl}
	\defrag 	& \ru & \rightarrow & \R \\
	& (r, r')  & \mapsto & r \Join r'
	\end{array}
	$$
\end{defi}

\subsection*{Chiffrement et déchiffrement}
Vu que pour l'instant on s'intéresse uniquement aux contenus des 
tables pour démontrer la correction sémantique des lois
de composition, on ne parlera pas pour l'instant
des éventuelles clefs de chiffrement et déchiffrement.

\begin{defi}
	On appelle \emph{chiffrement} tout couple $\typeT{c}$ de fonctions
	de $\val$ dans $\val$
	$(\enc, \dec)$
	vérifiant
	$\displaystyle \dec \circ \enc = \id$.
	
	Pour toute valeur $v$ de $\val$
	on note $\cy{v} = \enc(v)$
	et $\dc{v} = \dec(v)$
\end{defi}

\begin{defi}
	Pour une ligne $l$ définie sur $\Delta$, pour $\alpha$ un attribut,
	et pour $\typeT{c}$ un chiffrement,
	on appelle \emph{version de $l$ chiffrée pour $\alpha$ avec le chiffrement
		$\typeT{c}$}
	la ligne notée $\cy{l}_\alpha$ définie par:
	$$
	\left\lbrace
	\begin{array}{lll}
	\forall \beta \in \Delta \setminus \{\alpha\} & \cy{l}_\alpha(\beta) = l(\beta) & \\
	& \cy{l}_\alpha(\alpha) = \cy{l(\alpha)} & \text{si $\alpha \in \Delta$}
	\end{array}
	\right.
	$$
	
	De même, on définit la \emph{version de $l$ déchiffrée pour $\alpha$ avec le chiffrement
		$\typeT{c}$}, notée $\dc{l}_\alpha$, par:
	$$
	\left\lbrace
	\begin{array}{lll}
	\forall \beta \in \Delta \setminus \{\alpha\} & \dc{l}_\alpha(\beta) = l(\beta) & \\
	& \dc{l}_\alpha(\alpha) = \dc{l(\alpha)} & \text{si $\alpha \in \Delta$}
	\end{array}
	\right.
	$$
\end{defi}

\begin{defi}
	Pour $\alpha$ un nom d'attribut
	et \typeT{c} un chiffrement,
	on appelle \emph{fonction de chiffrement de $\alpha$ par \typeT{c}}
	la fonction
	$$
	\begin{array}{llcl}
	\cryptCAlpha : & \R & \rightarrow & \R \\
		&	r	&	\mapsto & \{ \cy{l}_\alpha / l \in r \}
	\end{array}
	$$
	
	De même, on appelle \emph{fonction de déchiffrement de $\alpha$ par \typeT{c}}
	la fonction
	$$
	\begin{array}{llcl}
	\decryptCAlpha : & \R & \rightarrow & \R \\
	&	r	&	\mapsto & \{ \dc{l}_\alpha / l \in r \}
	\end{array}
	$$
\end{defi}

\subsection*{Agrégation}

\begin{defi}
	Pour $\delta$ un ensemble de noms d'attributs,
	et une relation $r$, 
	\emph{on note $r_\delta$} la relation
	$$
	\{ l|_\delta / l \in r \}
	$$
	
	Notons que $r_\delta$ étant un ensemble, il n'a pas de doublons.
\end{defi}



\end{document}